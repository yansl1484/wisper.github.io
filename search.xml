<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[计算机网络原理（三）：传输层]]></title>
    <url>%2F2019%2F05%2F03%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82.html</url>
    <content type="text"><![CDATA[传输层在5层参考模型中，位于应用层和网络层之间，向下使用网络层提供的分组传输服务。向上为各网络应用提供端到端的报文传输服务。 传输层的基本服务传输层功能核心任务是为应用进程之间提供端到端的逻辑通信服务。功能： 传输层寻址 对应用层报文进行分段和重组 对报文进行差错检验 实现进程间的端到端可靠数据传输控制 面向应用层实现复用与分解 实现端到端的流量控制 拥塞控制 但是并非所有的传输层协议都需要实现以上的全部功能，比如UDP就不提供可靠数据传输服务。数据在传输层被称为传输层报文段。 传输层寻址与端口TCP/IP体系结构网络中用“ip地址+端口号”来标识一个通信端点。端口号用来在网络应用进程进行标识，不同的主机可以使用相同的端口号，因为端口号只本地有效。传输层端口16位整数（二进制码），其中0~1023为熟知端口号。通常把熟知端口号派给一些重要的网络进程，比如http服务器、ftp服务器等，而客户端通常在客户进程运行时动态地选取未被使用的端口号使用，通信请求总是由客户端发起，等服务器接收到客户端请求之时已得知其端口号，相应时便用此端口号返回数据给对应的进程。 无连接服务和面向连接服务无连接指的是数据交换前无需进行任何数据交换（握手），直接发送报文段。面向连接指的是进行数据交换前先交换一些控制信息，建立逻辑连接，在数据传输完毕之后还需要拆除连接。传输层的无连接协议是UDP，面向连接协议是TCP协议。]]></content>
      <categories>
        <category>自考</category>
        <category>计算机网络原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[哈佛幸福公开课：完美主义]]></title>
    <url>%2F2019%2F05%2F03%2F%E5%93%88%E4%BD%9B%E5%B9%B8%E7%A6%8F%E5%85%AC%E5%BC%80%E8%AF%BE%EF%BC%9A%E5%AE%8C%E7%BE%8E%E4%B8%BB%E4%B9%89.html</url>
    <content type="text"><![CDATA[我在自制力提升以及自我时间管理当中，经常容易犯“破罐子破摔”的错误。什么叫做“破罐子破摔”？这是一种典型的完美主义体现方式。比如：现在是51放假，我在放假之前就规划好，这5天的假期都要用于学习，不能把太多时间花在娱乐和放松上。但是由于制定的目标过于理想化和主观化，忽略了“人不是机器，也需要放松和娱乐”这个最简单的客观事实，在进入假期的第二天我就偏离了预想的轨道——我放松了，于是乎，在完美主义的心理模式下，我认为这个假期就算是彻底失败了，因为它没有完全按照我的规划来进行的，我没有完完全全地完成我既定的任务，那么它就是失败的。这是一种极端的心理模式，它在很多方面认为事情是两极的，没有中间属性，要么就做到最完美，要么就完全不做。在这样的心理状态下，如果事情偏离了预想的轨道，心里的想法就是“反正都是不完美了，都失败了，那接下来的事情还也没什么搞头了”，这就是所谓的“破罐子破摔”。这样的想法往往会导致严重的后果。本来，失败是人生中最正常不过的事，而且将没有做到极致的完美就定义为失败的这种行为本身就是荒唐的，因为世界上没有什么是完美的。而有这种心理模式的人，“破罐子破摔”只是其在行为上体现的一个方面上的一点。我忘记了我是什么时候有这种心理模式的，大概是小时候受到的“聪明”夸奖过多以及其他各方面复杂的因素所导致。近年来我一直在试图提高自己的自制力，把更多的时间花在学习上，想更高效地提升自我。但是以前荒废得太久了，所谓积重难返，现在又想在很短的时间内跃变为自控力超强的高效学习者，是确实有点急于求成了。在最近的一年多来，我与自己作斗争，在“成功自控一段时间——失控一段时间——再恢复自控”这个循环中反复，而我在这个过程中，“失控”的导致原因往往是因为极端的“破罐子破摔”思想，由自己半天没有学习这个诱因，引发“滚雪球”式的连锁反应，最终甚至于两度导致失控长达1个月以上——两个月除了玩游戏什么也没干。觉得自己的行为稍偏离了规划了，不完美了，于是在心里产生自责、焦虑等情绪，再因为人的心理保护机制，越是焦虑越需要寻找短暂的快乐和刺激，就导致了长期的放纵。现在是下午，可是我的一天才刚刚开始。为什么这么说呢？因为昨天我本来打算在12点之前睡觉，可是到了12点的时候还在弄一些别的事情，弄到了12点多一点。按道理说这时候应该及时止损，立刻睡觉的。可是这时候我就产生焦虑了：“说好的12点之前，结果12点多了”，加上傍晚的时候刚看了负面新闻，什么马云996福报，资本家阶级斗争之类的东西，焦虑更甚，于是看电视看到1点多。到了一点多的时候，心里想“今晚不能保证睡眠了，明天的精神状态肯定很差”，焦虑进一步加重，不知不觉到了3点多，实在熬不住了才睡。所以这就是为什么我的一天才刚开始，因为我是睡到中午才起床的。我起来后意识到，我又一次陷入了怪圈，我想在网络上寻找突破这种循环陷阱的方法，于是看到了哈佛大学的公开课——Tal教授的《幸福公开课：完美主义》。打开视频的时候我一看这节课有80分钟，我就在想这80分也太长了吧，能不能快速看完立刻获得成效，自己马上就克服了负面心态呢？可我还是克制了，把这节课看完了，现在只能说是有收获的。哈佛大学公开课：幸福课 完美主义 下面是文字版：第十五课 完美主义(全) 大家好，上节课我们学到了休整，时不时地放下工作，放松一下自己。我想邀请你们参加一项传统并且有历史渊源的休整节目，犹太安息日。这周五晚上，大家来Mac中心享用犹太安息日大餐，欢迎来到Mac中心的露天平台，和你的朋友们一起享用免费大餐，我们的Tal Ben-shahar教授将发表讲话，中心将于六点半开门，晚上七点开始，如果想参加请迅速在http://Shiva1000.org上回复。所有人都欢迎前来。 每年只要我一讲到完美主义的课，就有点坏事发生，第一年，我是记得我把电脑放在家里，第二年投影仪有坏了。而这一年我忘了带电源线了，把电源线放在家里，所以希望这点电源支持一个学期。如果不行的话，我们只能面对不完美了。但是其实也没关系的。这肯定是潜意识的问题。因为这也太巧合了，每次都有这些事情发生。的确是这样，那么上次我们讲到哪了，上次我们讲到你们是如何学会走路的，我们讲到你们是怎么学会画圆圈的，都是通过不断的失败。没人喜欢失败，失败让人受伤，让人极度失望，让人沮丧，也经常使人尴尬，但是那些最为成功的人，都会认识到失败和从失败中学习的价值。有一本非 常好的书《极客与怪杰》，他发现，有一些非常有趣而且很有意义的差异，存在于年轻的二十多到三十出头的成功人士和年长的成功领袖之间，其中最明显的差异就是工作与生活的平衡。对于年老一代的成功人士，这几乎就是外来观念，因为他们总是处在工作中，在那个样本中所有人都是男性而女性则呆在家里负责生活的那部分，所以说他们的工作和生活的平衡是丈夫负责工作，妻子负责照顾生活。 在年轻成功人士的样本里，男女都有，他们自然会谈到工作和生活的平衡。两代人之间还有其他的不同，但也有一个相同点，这一点对于两代人都是一样的，那就是至少有一次，一般来说是多于一次，显著的失败。Warren Bennis称之为考验，一次灾难。无论是一次重要的竞争失败，或者失去工作还是受到了侮辱失去了亲人。一些严重的失败，一次失败的经历，这是两代人共同 拥有的特点，他们都将失败作为一个关键点，一个生活的转折点，一些帮助造就今天的他们的因素。再说一遍，我不是说已经发生的是好事，而是他们能好好利用已 经发生的事，每个人都会经历考验，都会面临困难和阻碍，但是那些极度成功的人，如Warren Bennis书里所写到的那些人，和一般人的不同之处在于，他们能够好好的利用已经发生的事情，他们将这些事情看成机遇，一种学习的经历，一块垫脚石，这就是失败对于适应力和完善人格的作用。 我们继续来定义一下完美主义吧。因为现在有很多的定义。我们经常提及这个词，但我所要说的完美主义是什么？我的定义是一种充斥在我们生活中的对失败的失能性恐惧。尤其是在我们最在意的方面，注意“失能性这个词”，不只是对失败的恐惧。好吧，我也不认识哪怕一个不害怕失败也不会因为失败而感到尴尬或沮丧的人。这是很自然的，这是人性，不管我们喜欢不喜欢，但对失败的失能性恐惧是一种让我们在面对问题的时候裹足不前的恐惧。而我要在这个定义中强调的另一点是“尤其是我们 最在意的方面”。你们也明白，我在玩大富翁的时候可不是完美主义者，这也不是因为我的确很有竞争力，但对我来说胜败不重要。但是完美主义确实是我生活的重 心，比如说，就如同我提到的壁球对我来说非常重要，学术对我而言也非常重要，和别人的关系对我来说也非常重要。在这些方面，我就体会到了完美主义。也是 在这些方面，我必须并且一直在努力。在这些方面，让我详细说明一下，这是我们在面对人生的旅途的时候，也是我们从A点到B点的过程中，采取的一种方式，一 种认知和情感的基模。重点在旅途上面，一个最求卓越的人仍可能和完美主义者一样。或者比完美主义者更有野心，两者之间的不同，在于他们面对旅途的方式。我 来举个例子，首先是完美主义者，他正站在A点，他想到B去，什么是最完美最有效的方式呢? 就是直的路线。这就是完美主义者在面对旅途时所抱有的认知和情感的基模，怎么从起点到终点？一个最求卓越的人，和完美主义者一样雄心勃勃，也想从A点到B 点去，没什么不一样。不同之处哪里？对于这段旅途，认知基模上的不同。最求卓越的人明白，当他进步的时候，不可避免的会遭遇失败，一个最求卓越的人明白，有时候他不一定能拿他想要的分数，但他会吸取教训，一个也明白在恋爱关系之中，根本就没有完美的恋爱关系，所以他会犯错，她也会犯错，但他们都会不断地吸取教训，然后他们的感情不断地变得更加牢固。最求卓越的人明白，他需要不断的失败，五次十次有时候一万次，就如同我们了解的爱迪生的故事一样。一样的野心勃勃，但是基模有所不同。我必须画出许多不好的圆圈，在你们画出Vicent之前画出的那个圆之前。 现在的问题是哪个才更现实？拥有这样的基模是否现实（直线基模）？或者说这个（非直线型）才比较现实？我想这是很明显的。要达到成功可没有直线的捷径。 要达成一段快乐的恋情也没有捷径。要发明电灯泡也没有捷径。学好心理学也没有。想成为好的父母和朋友也没有，我们会犯错。而且自然的规则我们必须遵守。追 求卓越就是要克服困难，是啊，我也希望我能直线的从A到B。我希望我能做到，我希望我不必经历失败，我不喜欢不断地失败和打壁球输掉，我当然也不会喜欢和 我的妻子意见不合，我甚至希望宁愿没有万有引力定律，然后我就可以到处飞或者到处飘。而这就是幻想了。当我们的心中存在这个基模的时候，我们就 让自己反抗自然规律，就如同我们不接受万有引力定律的话，我们的生活就会充满不可和沮丧，我们活着，那么多人也活着，哈佛有不少人，不只哈佛，所以地方都 有，时常沮丧，因为在他们心里一直有这样的基模，再说一遍，这不是说我们该享受失败，但但我们有这样的基模的时候，同时又不享受失败，我们就会因为难以接 受事实而沮丧，拥有这样的基模也会有后果的，我就想讨论一下这样的后果，怀有拥有这种(直线)基模的人的一些特征。根本就没有 完美的完美主义者，就如我说的我们都存在一个闭区间内，确实有些人，确实有很多人更接近这个区间的这端，我想和你们分享这些特征，都是那些记载 在文学作品之内的，有很多人都拥有这样的特征，你们大多或多或少都拥有一些这样的特征，而不是别的特征，这也没关系。所以这些特征，除了都已被心理学著 作，详述之外，我都有过体会，或现在仍有所体会，所以这些特征对我来说具有一定的意义。他们本身也非常常见。 第一个是自卫性。在争论和讨论中，完美主义中都 有自卫性。为什么？因为批评在定义上就是一种对于我们的直线方式的偏离，这就是不完美，这就是一种挑刺。就是我没做到完美的事情，我们都不喜欢偏离我们所 持基模的东西，记住了，我们的心是不喜欢内在和外在之间的脱节的，我们需要的是平衡是一致，我们不喜欢横生枝节，而如果我们心中抱有的是完美主义的基模， 而批评又是对其的偏离，我们就会变得有自卫性，这是我多次有所感受的。并且也是我一直在努力解决的。附带一提，或者说正好相反，一个最求卓越的人是心胸开阔的。他会欢迎建议和批评，这不是说他或她喜欢这样，而是他或她明白这是必要的。这是成长和发展的必要部分，完美主义者只注意到空着的那半个杯 子。为什么？因为完美主义者为失败所困扰，被对直线的完美方式的偏离所困扰。而不管是什么，困扰我们的就是我们说关注的，他或她一直关注未能完成的东西， 关注潜在的可能失败或者真正的失败。追求卓越的人，则会关注已经满的那半个杯子。为什么？因为他或她既享受达成目标，又学会享受过程中的每一步，那就是旅途。即便是失败也能是机遇。完美主义者会过度一般化夸大化问题，非黑即白，要么是完美的，要么是一无是处。我 们等一下就能看到，这样的“全部或没有”的对立于现实的方法造成的后果。我们又谈到了明白现实是怎么样的，明白事物的过程是怎么样的。对于完美主义者来 说，说没有自我接受的；对于最求卓越的人来说，能够接受现实中存在的各种弯路，而没有一步登天的捷径，能够接受个人的失败，能够接受自己视作一个整体予以 接受。对于完美主义者来说，只有一种方式是合适的，并且是固定不变的，没有任何提升的空间，没有任何偏差，更没有问题和错误，只有一种方式，而不是动态 的。更有弹性和自发性的过程和旅途，在行为中自我证实。完美主义者恐惧失败，恐惧来自于内心的自己将自己视为失败者的失败，也恐惧他人将自己视为失败者， 就是为了维持那完美的幻觉。完美主义者恐惧失败，恐惧来自于内心的。自己将自己视为失败者的失败，也恐惧他人将自己视为失败者。就是为了维持那种完美的幻觉！而不是将失败视为反馈，不是说要享受失败，我还没遇到过享受失败的人。而是要将失败视为一种反馈和成长的机会。完美主义者只想着怎么到达这里，他们只关注这个，只针对目的！直来直去的，别的事情根本不重要，如果它不能让我达到目的的话。但对于追求卓越的人来说，旅途和终点都是成功的一部分。这样的基模上的差异，会导致很多的后果！ 我在这里列举一些。第一个就是完美主义者只能感受到，最多也只是，暂时性的轻松！是的！他们会感受到持续的压力，但当他们达到目的以后，他们感到了轻松！这就是典型的逐利者！ 我来给你们讲一个这样逐利者的例子！一个人，我们姑且称他为X先生，去上学了。在那之前，他一直很享受学前的生活，而他上学以后，就开始有压力了。 因为他明白，他必须很努力地读书。并取得非常好的成绩来上一个好初中。因为他父母想让他进的那所初中，竞争很激烈 非常不好进。他确实进了一间不错的小学。但是现在他要为初中而努力了，所以他有了压力，他并不享受小学生活。但他确实感受到轻松，在假期到来的时候，在全 家去度假或者考试结束的时候，在他可以不用担心考试和朋友玩的时候，他经过了小学阶段，却不怎么喜欢。他感受到轻松，却丝毫没有感受到在他还在幼儿园的时候感受过的那种：对于学习的热情与喜爱。他后来进入了梦想中的初中。那所他一直想要进入的初中，他做到了，他只在前两周里感觉非常高兴。因为他要开始考虑，他梦想中的高中了。为什么？因为那所高中，是进入全国最好的那些大学的垫脚石。他也很想进入间全国最好的大学。所以他在初中又很努力地学习！他并不怎 么享受这样努力的过程.但是他成功了，他进入了梦想中的高中，他很兴奋，从来没有这么高兴过！因为他已经是全国最出色的孩子中的一员。进这所高中不容易， 但是他做到了。然后他又开始学习，他又只开心一周，压力又来了。因为这所高中里面竞争非常激烈。他必须加入两个运动队，还有三个学生组织，因为他必须充实 他的简历好让自己进入梦想中的大学。他过的很挣扎，一点意思也没有。但是他对自己说：“这只是暂时的，痛苦是短暂的，等我进入了全国最优秀的大学就会有回 报的”然后他付诸行动。在4月2号，一封信来了！信的信封很大，他打开信知道自己成功了。他又感到非常的兴奋，甚至比进入高中时还高兴，然后他说：‘现 在，我终于能放手，好好的放松一下了。因为我已经进了这间大学，我的人生从此稳定下来了！’接下来他十分享受高中的最后一年，还有假期以及进入大学的第一 周，他很兴奋，这位X先生。但是在第一周过去后，压力又出现了，因为很快就会到其中考试。而很快又会出现激烈的竞争。并且每个人都和他一样努力，因此他也 必须非常的努力。因为他想得到他的梦想中的工作，他在大一暑假的时候得到了理想的实习机会，但是压力又继续出现了，他感受过轻松，也感受过愉快的时光。但 是这些都是在考试结束以后。或者假期即将到来之前，或者是在假期期间。但是每次都一样，压力又出现了，他自己也不明白为什么他不开心。因为这一切都是他想要的，他非常想要这些，多于别的一切。他说：“好的，只要我得到这份工作就好了！为什么？因为那份工作能让我进入最好的商学院。这能让我在一千六百个一同 毕业的人中脱颖而出！”所以他继续努力，继续充实他的简历！他是三个学生组织的成员，担任两个的部长！是两个大学运动预备队员，一个正式队员。还要加上每学期五门甚至六门课。为什么？因为这很困难，竞争很激烈。这就是适者生存，不付出就没有收获！大学最后一年到来了，他又有压力了。但是他得到了那份工作， 他很高兴！这就是他想要的.这就是他所预想的。现在他很高兴，然后8月3号到了。是他正式开始工作的第一天，他上班去了。他周围的所有人都是最高等学府的。毕业生都是最优秀学校的学生。他觉得已经功成名就，却只高兴了两周，因为在两周以后，他又感受到了非常大的压力！比大学里的压力还要大。他没有时间再 像大学里面一样在饭堂里悠闲地吃饭。他每周工作八十到九十小时，一点也不享受！但是他会做到的，他会做得很好的！他会得到一封很好的进商学院的推荐信。在 从商学院毕业以后，找到一个真正的理想工作并享受生活！然后他真的进了最高的商学院，也找到了他最好的工作。工作上，作为一个员工，他很高兴！事实上他甚 至不敢相信自己的好运！他赚钱赚的很多，那三年前看起来难以忍受的助学贷款，现在一下子就还清了。他感觉很棒，他有了一间很不错的公寓.他成了员工，他很 兴奋。他很高兴，“我终于做到了！”但是过了几个月，压力又回来了.因为他只是一个员工。他非常非常想成为合伙人。但当他成为合伙人以后，当他获得了“终身任期”以后，他的生活就可以安顿下来了。他继续努力工作，奋力拼搏。他不怎么喜欢他的工作，只要再努力多一点，在忍耐多一点痛苦，然后就会有真正的回报 了。在艰苦努力了五年以后，他有做到了，他成为了合伙人，事实上，也是那个公司历史上最年轻的合伙人.他很兴奋。他休了一个长假，然后回来工作。斗志满满，因为他现在是所有者。是这个著名的公司的所有者之一。现在他也已经成家了。他买下了市郊的一所大房子，非常贵。但他轻易买下了，他也买了一辆豪华车。 他还有了一个司机，他感觉真的功成名就了。他感觉良好地过了3个月，压力又来了！因为他只是一个初级的合伙人，他能成为高级合伙人吗？这可能吗？好吧！只 有努力工作才可能。因为没多少人能爬到金字塔那么高的位置！越来越难了，但是他会成功的。他挣扎着，忍受着，一点意思也没有。但是他成功了，没有付出就没有回报。这一次，他在Hamptons区买了一栋房子，用来度假和休息。还有一辆新车，更大也更快！然后他说：“我终于，终于能够放松了！”然后他开始放 松自己，过了两个半月，压力又来了，因为他只是个高级合伙人，但是常务董事只有一个，想得到那个位置是非常困难的。但是他决心要当上常务董事。他一直是明星级人物，没理由止步不前，这对他来说没什么乐趣可言。他没有花多少时间和他爱的人在一起，而因为他心中的焦虑他必须证明自己。足足花了七年时间，在这七年里，他在物质上已经很富足了，只是愈发缺乏时间，他不断的奋斗，最后终于成功了！董事会发表了人名声明，他登上了华尔街日报的头版新闻。X先生成为了这件传奇公司的常务董事，他的朋友祝贺他，他感到万分自豪，他很快乐。但是随后焦虑回来了，有一天他走进办公室里，坐在椅子上，脚搭在桌子上。他已经成了老 板，成了掌门人，他回头就可以看见中央公园，那景色实在是太美了。他真的是而不是修辞的说，他真的站在了世界之巅。然后有人敲门了，他被敲门声吓了一跳， 因为一般来了人他的秘书会向他通报，访客不会就这么过来敲门。毕竟他是站在世界之巅的人。于是他走过去开了门。来人是董事会主席，他们俩互相打了个招呼。 然后董事会主席说‘今年的盈利记录，非常棒，不可思议，您做的太好了！我们都为您而骄傲，感谢您的存在！但是，您应该退休了，您已经72岁了。’这就是逐利者的生活。 最佳情况下，当然这只是大概的描述。我只是着重描述了几个特殊的阶段，这也不是要么全部，要么没有，但是，总的来说，这就是逐利者的生活。只关注从 A点到达B点。然后轻松半个到一个月，然后 …B点又变成了新的A点。然后就像一直不断向上爬的老鼠，你们必须现在就问自己，不！现在问那还要等多久？你们必须现在就问自己，“我到底想要什么样的生活？”我 给的是一个生意场上的例子，其实对于其它领域也一样！不管你是想成为一个医生，是因为能否上到最好的学校而有压力？是想要最好的公寓？最好的实习机会？最 想要的好的，最高的职位等等！或者你是打算为非盈利机构工作。无论你是留在学术界，还是成为律师，都一样，都是在不同领域重复X先生的故事。这样的情况适 用于任何方面！问题就是“我们想要什么样的生活？”要记住其中最重要的，一个追求卓越的人，不会放弃自己的雄心！但是，一个追求卓越的人，也不会放弃整个旅途！我 们很快也会讲到，追求卓越的人，不仅仅不会放弃整个旅途或者结果，他们常常会获得更高的成就！我们很快就会讲到，追求卓越的人，并不只关注短时间的放 松，还关注长久的满足，是的，生活中会有起起伏伏！但是，也能够享受旅途中的每一天！在大学里的经历，和朋友们美美的吃了一餐的经历，阅读名家的作品的经历，上有趣的课，参加有趣的课外活动的经历，并且重视这样的经历，而不是忽略它们。不是把这些看做普通的，为了成功的最终目的。我们必须经历的事情，你或许会非常渴望成功，但是你所在的却是此时，此地，不是别处。我从来没有遇到过完美的人，我认为这样的人不存在，换句话说，如果根本就不存在完美的人，那么对每个人来说，失败都是不可避免的。为失败所困惑的完美主义者，只是专注于失败。而追求卓越的人，则会发现路途上每一步都有成功的机会！甚至在失败中也有这样的机会。完美主义者常常讲时间浪费在必须读清楚每个字，“我要做到最好，拿满分！”要么全部要么没有，要么我交上去一份完美的论文，要么我就干脆不交论文，要么我就拿到A，要么我就一无是处。要么全部，要么没有，有时候这是合适的，有时候追求卓越的人也会持有这种态度！比如，如果你是一个医生，你想做一场完美的手术，你不会说“好吧!没关系啊！我切对了八块应该切的东西”没错，在有些场合，你会需要完美主义，但是在我们生活中的其它方面，都不必要！甚至会伤害我们。 完美主义者往往倾向混乱！我是指多方面的混乱。比如进食问题，我来给你们提供一个，个人的例子吧！在我还在打职业壁球的时候，我必须控制我的食谱，要吃的健康吃的好！但还是产生了问题。我的生活中 有一项重大的挑战！这挑战就是我母亲是完美的大厨。她做的蛋糕尤其诱人.于是就有了这样的，我在长大的时候，常常遇到的状况，痛苦的童年！我在壁球训练过 后回家，饿的要命的打开冰箱，然后那里面有一大块蛋糕，实在是非常诱人！我根据以往的经验知道，这很好吃。我看着这块蛋糕，然后关上了冰箱门。因为我不能吃，当时我正在为一个重要的巡回赛训练。但是在三分钟以后，我回到冰箱那看蛋糕还在不在，为什么？你们 中认识我兄弟的都明白，我兄弟的块头比我大多了，他对我母亲的厨艺的喜爱，一点不在我的之下。所以我去确定蛋糕还在那，确实还在。过了十分钟，我必须再去 检查一遍，因为我兄弟在我视线内消失了几分钟。我以为他到冰箱那去了。所以我又打开了冰箱一次，蛋糕还在，然后我感到一阵轻松，大约五分钟以后，我又回到 冰箱那里。我打开冰箱们，两分钟以后蛋糕就不见了。要么全部，要么没有，要么我不碰，要么我吃完。这就是完美主义者持有的基模。不会说“好吧！我就吃一块”要么不吃，要么吃完！所以这就是完美主义者的基模。我要么成为超级模特，要么超重。要么全部，要么没有，这是很有破坏力的，这会对我们产生各个层次的 严重伤害！相对于健康的方式而言，好的，我就吃一小块。好的，我重了几磅，这算大事吗？我是人！我不是机器人，也不是芭比娃娃。这很伤自尊。为什么？因为Nathaniel Branden写过很多关于自尊的文字，我们在未来三周内将会更多的讲到他。自尊的第一个基础就是自我接受！要记得完美主义者是不接受自我的！ 第二个伤害自尊的原因是，完美主义者总会遇到长期且不可避免的失败！因为根本就没有完美的人。而如果我一直失败或者视自己为失败者，那我还会有较高的自尊心吗？当然不会！另一个完美主义者容易自尊心受伤的原因，是他们更不愿意去尝试。而如果我不愿意尝试的话，其后果就是，更加低的自尊心。还记得自我知觉理论吗？相对的事持续的自我提升！不是一条直线直上去的，而是旋转向上的！ 完美主义伤害人际关系!回想过去，我从这个角度来说，我很难捉摸，我基于完美主义，在人际关系中所犯的错误的类型，为什么？第一，自卫性！如果我一直是处于自卫性的位置，如果我不能接受或者处理批评，那我就很难和别人形成亲密的关系。这样的情况喜爱怎么可能建立亲密关系呢？ 另一个完美主义伤害人际关系的原因是，我们经常，我们对世界的看法和对自己的看法一样，如果我是完美主义者那我期望的就是完美。对我来说是一条直线，对他人亦是如此。不论是对于我的伴侣还是对我的孩子和朋友。没有完美的人，我们第一次见面的时候可能感觉 是完美的，在度蜜月的时候也是完美的。他或她是完美的。但是突然，我们开始发现对方的缺点了，那不是我一开始以为可以在一起的那人。当然，如果我期待的是 芭比娃娃或KEN的话，完美的。但是对方可是人。如果我从对方身上期待的是完美的，我肯定会失望的。这也会引起沮丧，对自己的伴侣不认可，也常常会伤害到人与人之间的关系。相对于持续成长的关系来说。这是我们会在谈论人际关系的时候谈论到的理想的人际关系，不是一个没有失败，没有不和的关系。理想的人际关系在包含众多积极因素同时也会包含不和，失望和争吵。那才是健康的人际关系。这让人际关系随时间变得更加稳固。 关键是其中的度，你在人际关系中包含的积极因素与消极因素各是多少？这里的关键不是只有积极而没有消极的因素，这样的关系是不健康的，这样的关系有过多的抑制与压抑。完美主义会导致焦虑和压力。总会有对于失败的恐惧，而不是 兴奋。这就是Perter Senge所说的“创造性张力”。 但是表现如何？那句已经镌刻在我们心中的“没有付出就没有收获”的真言呢？我是说我们很清楚地都知道我们必须要努力才能成功，那难道我不应成为完美主义者 吗？而人们不愿意放弃这种方式的一个原因是：他们认为这是最快的方法，是最为有效的通往成功的方法，但是最后事情往往都不是那样的。 长久来看，追求卓越的人 往往会取得更好的成就。在这方面有很多研究进行了阐释。我来举出一些成果，一些原因。现在说说少一点付出多一点收获。首先，以终极货币的形式，用幸福来进行衡量。追求卓越的人远比完美主义者要更快乐，这很好，也很棒。但也不仅仅是在终极货币价值方面，在硬通货等物质方面也是同样的。不管是工作上的成功，还是体育上的成功，还是处理人际关系上的成功。为什么，其中有很多原因。首先，追求卓越的人享受更加持续的成长。 记住了，这个我从环保方面引用的词——可持续增长。不是关于创造富饶的环境的，不是关于回到以狩猎与采集为主要生活方式的时代去的。是关于以现代生活方式生活，是关于享受进步与现代性。与此同时，不从环境中索取过多，让发展得以持续下去。 放到个人层面上也是一样的，完美主义者不会享受持续性的成长。因为他 们不允许休整和偏离。所有东西都是不变的，如同一台机器。至于追求卓越的人，有所偏离，有所中断，也有休整，想做起来更加可持续。如果我受伤了。我的壁球 生涯就结束了。因为要么全部要么没有，要么我就完全不训练，要么我就像世界冠军Jansher khan那样训练。同时追求卓越的人所拥有的固有动力也比完美主义者高很多，当我们有固有动力的时候，我们就能更好地再一段时间内持续地付出努力。如果所有的动力都是固有不会减退的，那就能上升到另一个层次获得嘉奖或者能得到升迁。丘吉尔说完美主义让人瘫痪。当我们被失败所困扰的时候，我们就更不会付诸行动。完美主义是事情耽搁的最主要原因之一，对失败的失能性畏惧。因为只要我们不行动，我们就不会失败，就如同我之前说的，追求卓越的人的自尊相比起来更高，而且 如Nathaniel Branden所说，自我觉知是终点，而信念变成自我实现预言。如果我相信我自己，如果我认为我能成功，如果我的过去有跌倒之后又爬起来的经历，那我就更 可能成功。你们读到了“运气的因素”英国的Wiseman教授极为优秀的作品。他所说的是， 比别人有更多运气的原因似乎是一件很神秘的事情。但其实也是可以用科学方法解释的。其中一个有更好运气的方法，便是尝试新事情，小事情，即使是你课后去食堂的路上，找一条和你每天所走的那条路有些许不同的路线。而她说，这些小事就可以改变我们的生活， 这些小小的对于直线方式的偏离实际上能带来更多的幸运，因为我们开始看见以前没见过的东西。完美主义者只有一条路。没有偏离，没有进步，没有自发性。这些 时常都让我们变得不那么“幸运”。说到创造力。Simonton说，那些历史上最成功最有创造力的科学家和艺术家都是那些失败得最多的。他们都不是完美主义者。他们都追求卓越，非常有雄心，都明白要成功没有别的方法。John Updike一位非常有创造力的作家，说过“完美主义是创造力的敌人”。我们会谈到另一个作家。他对于我们如何克服这种完美主义有非常好的建议，他叫Samuel Coleridge。80/20规则。这条规则。了解这条规则并将其应用在时间管理上改变了我在哈佛的学习经历。那帕累托法则是什么呢？帕累托是100年前的意大利经济学家。他得出了这样的法则，并将其命名为帕累托法则。这法则表示，在大多数社会中，百分之二十的人拥有百分之八十的财富。他们也将这条法则应用于商业组织，那就是你百分之二十的客户给你带来了百分之八十的收入。这也被用于经济学的许多领域。而到最近被用于时间管理方面。比如说，在我们百分之二十的时间里，我们可以完成百分之八十的工作。而当我明白这一点的时候，它改变了我对学术的态度。为什么？因为我意识到我不必将那些材料完全读完。再说一遍，这点别学我。我交论文前不必确认每一个t都写 好了也不必确认每一个i上面都点了点。我开始遵循更多的愉悦原则，或者说快乐原则，于是我说“好的，这才是我感兴趣的东西”。比如说，文学与艺术学院课程C14“英雄”，这是我本科时候最喜欢的课程。而且这课程还不算太难。我完全可以不怎么努力也得到好成绩。但是我在这科的期末论文上花了50个小时。因为我写的主题是我非常关心的。但是我没有得A，对我来说毫无道理。但我仍然在上面下了大工夫。因为这实在是太有意思了， 至于其它课程，我只投入了能让我得到足够成绩的时间。不是要么全部要么没有。不会说要么我就得A，要么我就不学习。另一门课，还 是文学与艺术，Maria Tatar教的“神话故事”，。我本科时看见她第一眼就爱上了她。我真不敢相信我就这么说出来了。那么，她拒绝了…其实我没有问她…也是在那门课上，不算太难的课，在许多层次上来说非常享受的课。又一次，我花了许多时间在这篇最终成为一篇以自尊为主题的专题论文之上。所以再一次问自己到底什么才是最重要的？除了要么没有要么全部外，我还在乎什么。我的成绩确实下降了一点点。但是只是很少一点点。因为我在应用这条20/80法则。将百分之二十的注意力放到重要的东西上然后把百分之八十的工作做好。而我在学术的其它领域却获得了更多的成功，因为我有了更多的时间来打壁球来享受壁球练习。我有了更多时间来和别人交流。有时间去坐在法学院里吃一次五点开始的，持续两个半小时的晚餐。就是这样的基础上实现的。 另一个对于80/20的应用：我们每人在一天中都有不同的最有工作效率的时间。实际上，在一天中百分之二十的时间内，我们完成了百分之八十的工作，这取决于我们是早起的鸟还是夜猫子。有的人早上6点或7点就起来了，然后他们立刻就可以工作了。我也是这样的，我很早起床，对我很简单。我可以直接开电脑工作或去给孩子换尿布。很早的早上直接去工作没问题。但是到了晚上9点到10点就完全不行了。有人却是截然相反的他们可以熬夜到凌晨2点3点4点，那才是他们最有干劲的时候。这和我们内在的生物节奏有关，和我们的生理节奏有关。因为基本上没有人的周期是正好24小时的，大多数人都是23到25小时之间。对于周期是23小时的人来说，他们到 了晚上就会非常疲劳。但是他们早上却会精神抖擞地起来。那些周期是25小时的人早上需要多睡一会。就是因为那些人我才将这课调到11点半。我知道是很早但是感谢你们的到来。我上大学的时候，大多数人都学到很晚。我的室友就学到很晚，从晚上10点开始然后学到12点甚至凌晨2点。这才是他们最有效率的时候。 可我不是。我宁愿早上早点起来，我在晚上会很累，根本无法集中精神。我听说了这样的效率时段后，我改变了作息。我早早睡觉。在我的室友开始学习的时候，我上床睡觉，然后在我的室友还在睡觉的时候起床，然后在早上早早地把工作完成，做完以后去上11点的课。在早上的那3个小时内，我完成了更多东西更有效率更有创造性，比我在晚上熬夜有效率得多了。我刚才说到的那两样东西真的改变了我在这里的经历——在更短的时间内学到更多。不是完美主义的方式，是追求卓越的方式。 大家都了解过“流动”了，Mihaly Csikszentmihalyi谈论过流动是我们最良好的感受，最出色的表现，也就是“没有付出就没有收获”。我们什么时候感受到流动？我们焦虑的时候感受不到，就如完美主义者那样，我们无聊时感受不到，只有我们乐观愉快，兴奋的时候感受得到。追求卓越的人更容易感觉到流动， 我来谈谈完美主义的根源吧。因为一旦我们明白它是怎么来的，我们就更能克服它——完美主义的根源。第一个，最重要的因素就是社会影响。我们都不是天生的完美主义者。 你们在录影带中看到的孩子，他们天生比我们更能享受学习的过程。我们畏惧失败，他们却不断跌掉了又爬起。所以是社会的影响导致了我们对于失败的畏惧，确切地说，是这样一种在我们心中烙下的并且几乎从出生开始就不断被加深的基模，那就是，成果才是真正重要的。当我们得到了某个成果的时候比如学会走路，做得好。我们的成果受到了奖励。过了没多久，我们就开始内化这种基模并且我们也开始相信我们接受它。当我们达成了某种成就的时候，这样的事在我们生活中一直延续着。我们什么时候会得到奖金？在4月3号吗？当然不是。是在12月31号。或者说是圣诞节之前，年末。今年大 家都干得不错。很好。我们什么时候会得到分数，还被别人轻拍后背表示做得不错？是在学期末，或是在考试后，我们完成了某些事的时候。不会在旅途中得到。换句话说，整个旅途都没有受到奖励。于是我们也就开始认为它是无关，是不重要得，只是到达终点的一种方式。只有非常少的教师，家长，组织，还有学校会奖励旅 途，奖励旅途中的愉快。当然，也有很少的人会奖励失败，可这是旅途中不可避免的。所以我们觉得这不好，这一点也不好，我们必须尽可能地追求直线。一种直接的基模。我们内化它的时候也付出了代价。这就是我们出生所在的社会环境，我们成长所在的社会环境，而这样的社会环境很难以改变。我也知道我家里也有孩子。 这太难以改变了，因为我自己也时常对孩子说并且专注于“Shirell学会走路了，做得好。你学会走路了”，而不是奖励其中所付出的努力，我们等会会讲 到。奖励付出的努力，甚至奖励失败应对与整个过程非常难。这当然也和准许为人有联系，准许看到人类本性的限制，而不是理想化，孤立地，分离地看待生活。因为这不可能。如果不是准许为人，而是要求完美的话压力是持久存在的。存在于媒体中。存在于工作中。存在于教育机构中。这无处不在。我们也为之付出了代价。现在我来给你们看几个例子。在那前先给你们介绍一下。你们都知道，学术研究赚不了多少钱。进入学术圈的人，大多都不是为了钱。有很多学者，我也不例 外，必须额外赚取收入。我也有额外的收入，而我希望和你们分享一下我额外做的事。(老师在杂志上只穿四角裤的腹肌封面照…)我的眼镜掩饰了我有腹肌的事实。那么，他是真实的？部分真实。这照片修过不少地方。但是没错，确实有人长是这样的。但是我们在杂志会看到什么？这些就是封面上的人物。十分完美，完美的存在，甚至更加。我们的KEN还有芭比娃娃都更加完美，不是么，看这个：“性爱女神的秘密”，这甚至不是“性爱人类的秘密”，那还不够好，看看我们为自己定下的这些标准吧。我怎么才能变成那样，“如何快速进步”，要多快有多快，对吧，时间不多，永远不长痘痘，“我都37岁了，还有痘痘”他们怎么做到的，又是不现实的模型。Anita Rdddick在女性和自尊方面做了不少工作，其中一个项目，她在1997年策划的，叫做Ruby的洋娃娃，用来取代芭比娃娃，那次活动是这样的：“有三十亿女人长得不像超级模特只有8个才像”。或者：“媒体们，在我们家乡，文化与生理的多样才是标准，那里就是地球。”这次活动非常成功，也很重要。因为我们今天文化中的模型就是这样的，要么全部要么没有，要么你大吃大喝，要么就是不吃不喝，我们从电影中得到了什 么，谁能达到《壮志凌云》里面的标准，汤姆克鲁斯和凯利麦吉利斯，他们拥有的那种完美的爱情，但这是我们所有的模型，等我们谈到恋爱关系的时候会讲到，谁又能度过《爱你九周半》那样的九周半呢？更不要说过一辈子了，那电影里的激情，都是不可能的标准，还有那些自助的书，比如《思考致富》， 只要思考，就能致富，这本书卖了几百万本，这里还有一本书，这本书不错，但我没有读过，但先看看《小步迈向幸福》，我们又迫不及待了，说的是专注于目标，而不是专注于努力、旅途、人格，还有所需的改变。 还有别的导致完美主义的因素，这是一个你们已经读到过的研究结果：不是所有的赞美都是好的，对于一个孩子说，你很棒，你狠出色，不乏赞美之词。你太聪明了，我的小爱因斯坦，这也不总是好的,长期来看着可能也是有害的，这也会导致完美主义的基模。 研究所做的就是找到一些十岁的孩子，然后把他们随机分成两组，第一组孩子都做了道题，到最后，对 每一个完成的孩子说：“你真聪明伶俐”当然，孩子们都感觉不错，第二组做的是同一道题目，做完了，做的不错，到最后，她说：“你真努力，你很认真”这随机 分成的两组孩子，一组是“聪明伶俐”，一组是“努力认真”。然后她开始第二部分的研究，第二部分，两组孩子要选两道题，他们被告知其中一道很简单，另一道非常之困难，但是他们能够从其中学到很多，第一组被称 赞为聪明伶俐的孩子中有5成孩子选了简单的题目，5成孩子选择了可以学到很多的难题，另一组孩子九成孩子选择了能学到很多的难题，这就是研究的第二部分。第三部分，这次她让孩子们做一道非常难题目，这题基本上是无法解答的，她想看看这两组孩子的反应，被告知聪明伶俐的那组他们没有坚持多久，并且非常沮丧， 并且很快就开始放弃了。与此相反，被告知努力认真的孩子他们更能坚持并且享受解题的过程，虽然到最后他们都没能解开这道题，但是他们享受了这个过程，并且 更加努力。看看这微小的操作带来的结果。简简单单的一个句子：“你真聪明”“你真努力”一句话带来了这么明显的不同，用她的话来说，“重视努力让孩子拥有一个他自己能掌控的变量”这能让他们认为自己能掌控自己的成功，强迫自然的天赋，让孩子们无法掌控成功，这不会给孩子们提供面对失败的方法，事实上当你仅仅注重于天赋的时候，你就是在制造完美主义的基模，而不是专注于旅途当中，努力的基模，她继续说道，“如果你称赞孩子的智力，当他们失败时，他们会认为自己不再聪明”然后失去对于眼前工作的兴趣，相反，那些被称赞为努力孩子，在困难面前不会气馁，甚至更有动力。这两种方式造成了多么明显的不同。被称赞智力的人会产生这样的基模，要么我很聪明，要么我就不聪明，我很畏惧不聪明，所以我就选择容易一点的任务吧，当我无法做到的时候，这就是攻击，是对于我的基模的侮辱，没错吧？这是对于直线的偏离。 相对的，如果努力才是最重要的，“好吧，让我试试吧”，“我学到很多，这真有意思”；因为一个是“既定思维模式”如Dweck所说，而另一个是种可拓展的，时刻改变和发展的思维模式；一个是畏惧失败，因为我想聪明，被人称赞聪明很有意思，我不想威胁到这个基模，相对的是：努力的、重视过程的，当追求卓越的基模，成为惯常的做法。 那么我们如何克服完美主义呢？如果我们确实有这个问题怎么办？要记住，根本就没有完美的完美的主义者，也没有完美的追求卓越者，你们必须选择你能快乐的生活方式，不会有现成的答案摆在你面前，对你而言可能只是有趣的学术理论，或者是非常个人化的原因。 那么我们该怎么更多地采用卓越的基模呢？首先，是自我认知，在于自我了解。 对我来说，明白“我太过于有自卫性了”，我不想再这样了，“是一个大突破”。因为我知道这会伤害人际关系，并且从那时候我开始在这上面努力，并且在 将来仍将继续提升我的人际关系，或者“看看我有多么畏惧失败”我有多么害怕听到那个不字，看看我有多么害怕被拒绝，看看我有多害怕应对与尝试，就应该意识 到它。如果你想让你的网球技术进步，你必须首先明白你想要进步的是什么，这就是第一步，说起来容易做起来难。我来给你们介绍一个简短的例子，是关于一个不 完全了解自己的弱点的人的。 视频：威尔和格蕾丝，第三季第十集片段。 不管是要应对上瘾问题，还是对于生活中别的问题，完美主义还是要改善什么，第一步就是要有意识，第二步是专注于努力的嘉奖，Carol Dweck向我们展示的就是当我们专注于努力的时候，我们就能够改变那种根深蒂固的基模，即便这种基模已经存在了多年，所以对于我们自己，或者对别人，我们应专注于旅途。专注，并不一定是嘉奖自己成功，甚至是嘉奖自己的失败 自己的尝试， 在几个小时内，如Carol Dweck所见，告诉人们他们的心是可以扩展的，告诉他们神经可塑性，并非已经定型，我们仍可以做出改变，积极的接受。我认为Karen Horney她是幸福学创始人之一，她在恐惧症领域做了很多工作，她研究所得的其中一点是恐惧症，它从来不会消失，它是我们的一部分，它会变得更加可控制，但是总是存在，而极度的完美主义也是一种恐惧症，所以关键就是接受它。我总会有完美主义倾向，但是这没关系，但是在以前，我有着极度的完美主义，现在 我更加接近追求卓越的极致，这是持续一生的，是不断进行的一个过程，所以现在的关键就是接受，它一直都是我们生活的一部分这一个事实，然后问：“好的，那 我该怎么办？”，换句话说就是采取行动，所以举例来说，就是怎么应对，把自己置于线上，我最初所做的，在我留意到我的完美主义与自卫性的时候，我会撇开我 的做法并且请求批评，我会问别人“给我点反馈吧”，当我收到反馈的时候，和我的直线有所偏离的时候，我就阻止自己回击。你们也知道，对于完美主义者来说， 最好的防守就是进攻，慢慢地我就习惯了，我没那么有自卫性了，我得以创造更高层次的亲密关系了，或者我开始尝试别的领域，那里我可能会遭到否定，让我以一 个故事结尾吧。 她的名字叫Brittaney，她是一位展示女郎，我们在大学第一周时认识，我对她一见钟情，我们几乎整个第一周都在一起，到那一周的周末，为了克服我的完美主义，我约她出来，她拒绝了，这让我很吃惊，很受伤，但是她确实拒绝了,在大学第二年，我们又见面了，我再次约她出来，她又拒绝了。第三年，在年末 的时候，我和另一个人约会去了，所以Brittaney就出局了。后来在我大四的时候我们又见面了，我们谈了些有趣的话题，那时候我已经开始学习心理学 了，我也可以读懂她的身体语言，她经常这么弄她的头发，然后我知道她确实很喜欢我，然后我约她出来，她拒绝了，然后我就还留在这里和你们在一起，这就是个 很重要的学习过程，学会失败，或败于学习。]]></content>
      <categories>
        <category>心理学</category>
        <category>自我成长</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[密码学基础]]></title>
    <url>%2F2019%2F05%2F02%2F%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8.html</url>
    <content type="text"><![CDATA[对称加密和非对称加密参考文章：http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html 对称加密算法 对称密钥加密（英语：Symmetric-key algorithm）又称为对称加密、私钥加密、共享密钥加密，是密码学中的一类加密算法。这类算法在加密和解密时使用相同的密钥，或是使用两个可以简单地相互推算的密钥。实务上，这组密钥成为在两个或多个成员间的共同秘密，以便维持专属的通讯联系。与公开密钥加密相比，要求双方取得相同的密钥是对称密钥加密的主要缺点之一 加密和解密使用的都是相同的密钥，这就导致在多方中只要有一方出现问题泄漏了密钥，那么整个团队就全部沦陷。 常见的对称加密算法有DES、3DES、AES、Blowfish、IDEA、RC5、RC6。 非对称加密算法非对称加密比对称加密更安全，但是相对效率要更低。 公开密钥加密（英语：public-key cryptography，又译为公开密钥加密），也称为非对称加密（asymmetric cryptography），一种密码学算法类型，在这种密码学方法中，需要一对密钥(其实这里密钥说法不好，就是“钥”)，一个是私人密钥，另一个则是公开密钥。这两个密钥是数学相关，用某用户密钥加密后所得的信息，只能用该用户的解密密钥才能解密。如果知道了其中一个，并不能计算出另外一个。因此如果公开了一对密钥中的一个，并不会危害到另外一个的秘密性质。称公开的密钥为公钥；不公开的密钥为私钥。 在双钥体系中，公钥用来加密信息，私钥用来数字签名。 常见的非对称加密算法：RSA、ElGamal、背包算法、Rabin（RSA的特例）、迪菲－赫尔曼密钥交换协议中的公钥加密算法、椭圆曲线加密算法）。 数字签名： 鲍勃有两把钥匙，一把是公钥，另一把是私钥。鲍勃把公钥送给他的朋友们—-帕蒂、道格、苏珊—-每人一把。苏珊要给鲍勃写一封保密的信。她写完后用鲍勃的公钥加密，就可以达到保密的效果。鲍勃收信后，用私钥解密，就看到了信件内容。这里要强调的是，只要鲍勃的私钥不泄露，这封信就是安全的，即使落在别人手里，也无法解密。鲍勃给苏珊回信，决定采用”数字签名“。他写完后先用Hash函数，生成信件的摘要（digest）。鲍勃将这个签名，附在信件下面，一起发给苏珊。苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。 数字证书： 但是并非表示非对称加密就没有安全问题。如果有人冒充公钥的发放者，导致使用者使用冒充的公钥进行加密，那么其加密内容对于冒充者来说，则是完全可见的。 继续上面的故事：复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。此时，苏珊实际拥有的是道格的公钥，但是还以为这是鲍勃的公钥。因此，道格就可以冒充鲍勃，用自己的私钥做成”数字签名”，写信给苏珊，让苏珊用假的鲍勃公钥进行解密。后来，苏珊感觉不对劲，发现自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找”证书中心”（certificate authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成”数字证书“（Digital Certificate）。鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明”数字签名”是否真的是鲍勃签的。 CA的公钥可以用于证明内容发布者的真实身份，被用户持有，称为根证书。 数字签名和证书的另一种表述： 比如在现实生活中，我们想给某个人在网上传送一个机密文件，该文件我们只想让那个人看到，我们设想了很多方法，首先我们想到了用对称密码将文件加密，而在我们把加密后的文件传送给他后，我们又必须得让他知道解密用的密钥，这样就又出现了一个新的问题，就是我们如何保密的传输该密钥，此时我们发现传输对称密钥也不可靠。 后来我们可以改用非对称密码的技术加密，此时发现问题逐渐解决了。然而又有了一个新的问题产生，那就是如何才能确定这个公钥就是某个人的，假如我们得到了一个虚假的公钥，比如说我们想传给A 一个文件，于是开始查找A 的公钥，但是这时B 从中捣乱,他把自己的公钥替换了A 的公钥，让我们错误的认为B 的公钥就是A 的公钥，导致我们最终使用B 的公钥加密文件，结果A 无法打开文件，而B 可以打开文件，这样B 实现了对保密信息的窃取行为。因此就算是采用非对称密码技术，我们仍旧无法保证保密性的实现，那我们如何才能确切的得到我们想要的人的公钥呢？这时我们很自然的想到需要一个仲裁机构，或者说是一个权威的机构，它能为我准确无误的提供我们需要的人的公钥，这就是CA。 这实际上也是应用公钥技术的关键，即如何确认某个人真正拥有公钥（及对应的私钥）。在PKI 中，为了确保用户的身份及他所持有密钥的正确匹配，公开密钥系统需要一个值得信赖而且独立的第三方机构充当认证中心（Certification Authority，CA），来确认公钥拥有人的真正身份。就象公安局发放的身份证一样，认证中心发放一个叫”数字证书”的身份证明。 ​ 这个数字证书包含了用户身份的部分信息及用户所持有的公钥。象公安局对身份证盖章一样，认证中心利用本身的私钥为数字证书加上数字签名。任何想发放自己公钥的用户，可以去认证中心申请自己的证书。认证中心在鉴定该人的真实身份后，颁发包含用户公钥的数字证书。其他用户只要能验证证书是真实的，并且信任颁发证书的认证中心，就可以确认用户的公钥。认证中心是公钥基础设施的核心，有了大家信任的认证中心，用户才能放心方便的使用公钥技术带来的安全服务。 数字证书在网络中的典型应用：https协议 这个协议主要用于网页加密。 1、首先，客户端向服务器发出加密请求。 2、服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。 3、客户端（浏览器）的”证书管理器”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。 4、如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。 5、如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。 6、如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息。 总结： 数字证书是在数字签名的基础上，加上第三方机构公证，以证明内容发布者的身份。前提是要保证这个第三方机构是可靠的。]]></content>
      <categories>
        <category>信息安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[oracle执行计划]]></title>
    <url>%2F2019%2F05%2F02%2Foracle%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92.html</url>
    <content type="text"><![CDATA[执行计划因为某些图片被限制了跨域加载，所以请见我博客园文章:oracle执行计划]]></content>
      <categories>
        <category>数据库</category>
        <category>oracle</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[中间件基本概念]]></title>
    <url>%2F2019%2F05%2F02%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html</url>
    <content type="text"><![CDATA[中间件：个人理解，早期WEB项目采用MVC架构，全靠一台服务器扛起来的，随着互联发发展，服务器压力越来越大，分布式框架被大量的运用在B2C等项目中，比如面相服务的SOA架构，所采用的方式就是将各个业务系统拆分开来，独自承担压力，这样的架构就保证了项目的高可用。那么问题也随之而来，各个服务间如何进行通信，使用点对点的方式后期发现调用易造成混乱，所以可以采用这个面相服务治理的中间件Dubbo。嘿嘿，那么中间件到底是干嘛的其实根据上面来说能够稍微知道一点，其实就好像上面大家说的，中间件跟业务无关，仅仅在做各个服务中连接问题，好像一个路由器一样，将所有的子系统统一管理，从dubbo的核心RPC和NIO也能看出来，主要还是在负责服务间连接通信。还有就是它要去使用还需要依赖一个注册中心，官方推荐Zookeeper，我的理解就是dubbo负责连接（就是用自己的方案来获取provider和customer的url）集中交给zookeeper注册中间统一管理。这样我们在调用服务的时候，只需要通过中间件，就可以完成。这样做的好处就是可以让我们不论是前端和后端人员，可以在大型的分布式系统中专注于自身业务即可 作者：(知乎)哈里亮链接 下面是oracle官方的解释：由于业务、机构和技术是不断变化的，因此为其服务的软件系统必须适应这样的变化。在合并、添加服务或扩展可用服务之后，公司可能无力负担重新创建信息系统所需的成本。正是在这个关键时刻，才需要集成新组件或者尽可能高效地扩展现有组件。要集成异类组件，最方便的方法不是将它们重新创建为同类元素，而是提供一个允许它们进行通信（不考虑它们之间的差异）的层。该层被称作中间件，它允许独立开发且运行于不同网络平台上的软件组件（应用程序、Enterprise Java Bean、Servlet 和其他组件）彼此交互。当能够进行这样的交互时，网络才成为计算机。原文地址：原文链接 自己概括一下：中间件就是对服务组件之间进行相互关联和通信的非业务性的组件。]]></content>
      <categories>
        <category>中间件</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[webService基本概念、元素及简单编码实现]]></title>
    <url>%2F2019%2F05%2F02%2FwebService%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E3%80%81%E5%85%83%E7%B4%A0%E5%8F%8A%E7%AE%80%E5%8D%95%E7%BC%96%E7%A0%81%E5%AE%9E%E7%8E%B0.html</url>
    <content type="text"><![CDATA[webService“网络服务”（Web Service）的本质，就是通过网络调用其他网站的资源。网络服务是相对于本地服务来说的，本机完成本机需要完成的任务，叫“本地服务”，而“网络服务”则是通过网络来调用其他服务器提供的服务。 webService和中间件的关系：webService是一种技术手段，是一种网络中系统之间进行交互的方式。而中间件则是实现这种交互的一种手段（一种软件、服务）。 定义：WebService是一种跨编程语言和跨操作系统平台的远程调用技术（rpc）。实现平台无关性和语言无关性的关键是用一种标准来统一定义相互通信的接口，而WebService平台技术就是旨在解决统一标准的问题。引用：Web service是什么？ WebService平台技术XML+XSD,SOAP和WSDL就是构成WebService平台的三大技术。SOAP和WSDL的详细格式和解析可见：SOAP和WSDL的一些必要知识 or 备用地址 XML和XSD： WebService采用HTTP协议传输数据，采用XML格式封装数据（即XML中说明调用远程服务对象的哪个方法，传递的参数是什么，以及服务对象的返回结果是什么）。XML是WebService平台中表示数据的格式。除了易于建立和易于分析外，XML主要的优点在于它既是平台无关的，又是厂商无关的。无关性是比技术优越性更重要的：软件厂商是不会选择一个由竞争对手所发明的技术的。XML解决了数据表示的问题，但它没有定义一套标准的数据类型，更没有说怎么去扩展这套数据类型。例如，整形数到底代表什么？16位，32位，64位？这些细节对实现互操作性很重要。XML Schema(XSD)就是专门解决这个问题的一套标准。它定义了一套标准的数据类型，并给出了一种语言来扩展这套数据类型。WebService平台就是用XSD来作为其数据类型系统的。当你用某种语言(如VB.NET或C#)来构造一个Web service时，为了符合WebService标准，所有你使用的数据类型都必须被转换为XSD类型。你用的工具可能已经自动帮你完成了这个转换，但你很可能会根据你的需要修改一下转换过程。 xsd就是基于xml，自己定义了一套标签，用来对webService中的数据表示格式进一步规范。 SOAP： WebService通过HTTP协议发送请求和接收结果时，发送的请求内容和结果内容都采用XML格式封装，并增加了一些特定的HTTP消息头，以说明HTTP消息的内容格式，这些特定的HTTP消息头和XML内容格式就是SOAP协议。SOAP提供了标准的RPC方法来调用Web Service。SOAP协议 = HTTP协议 + XML数据格式SOAP协议定义了SOAP消息的格式，SOAP协议是基于HTTP协议的，SOAP也是基于XML和XSD的，XML是SOAP的数据编码方式。打个比喻：HTTP就是普通公路，XML就是中间的绿色隔离带和两边的防护栏，SOAP就是普通公路经过加隔离带和防护栏改造过的高速公路。 soap基于xml和http，在http的请求头中加入属性用以标记请求内容格式是soap类型的，并且用soap也是和xsd一样，基于xml的基础上自己定义一套标签，来规范webService请求的一系列参数。 WSDL： 好比我们去商店买东西，首先要知道商店里有什么东西可买，然后再来购买，商家的做法就是张贴广告海报。 WebService也一样，WebService客户端要调用一个WebService服务，首先要有知道这个服务的地址在哪，以及这个服务里有什么方法可以调用，所以，WebService务器端首先要通过一个WSDL文件来说明自己家里有啥服务可以对外调用，服务是什么（服务中有哪些方法，方法接受的参数是什么，返回值是什么），服务的网络地址用哪个url地址表示，服务通过什么方式来调用。WSDL(Web Services Description Language)就是这样一个基于XML的语言，用于描述Web Service及其函数、参数和返回值。它是WebService客户端和服务器端都能理解的标准格式。因为是基于XML的，所以WSDL既是机器可阅读的，又是人可阅读的，这将是一个很大的好处。一些最新的开发工具既能根据你的Web service生成WSDL文档，又能导入WSDL文档，生成调用相应WebService的代理类代码。WSDL文件保存在Web服务器上，通过一个url地址就可以访问到它。客户端要调用一个WebService服务之前，要知道该服务的WSDL文件的地址。WebService服务提供商可以通过两种方式来暴露它的WSDL文件地址：1.注册到UDDI服务器，以便被人查找；2.直接告诉给客户端调用者。 WSDL也是在xml的基础上进行扩展，它是用来描述webservice的，描述了WebService有哪些方法、参数类型、访问路径等等。 UDDI： UDDI的目的是为电子商务建立标准；UDDI是一套基于Web的、分布式的、为Web Service提供的、信息注册中心的实现标准规范，同时也包含一组使企业能将自身提供的Web Service注册，以使别的企业能够发现的访问协议的实现标准。也即一种远程服务发布与注册的标准。 Web Service调用方式网络上随处可见的“四种调用webService的方式”都是通过jdk1.6之后集成的组件api进行调用。随处找来的：WebService的四种客户端调用方式（基本）还有其他的开源框架实现了Web Service，比如axis和cxf。 在SOA领域，我们认为Web Service是SOA体系的构建单元（building block）。对于服务开发人员来说，AXIS和CXF一定都不会陌生。这两个产品都是Apache孵化器下面的Web Service开源开发工具。 Axis2的最新版本是1.3.CXF现在已经到了2.0版本。 这两个框架 都是从已有的开源项目发展起来的。Axis2是从Axis1.x系列发展而来。CXF则是XFire和Celtix项目的结合产品。Axis2是从底层全部重新实现，使用了新的扩展性更好模块架构。 CXF也重新的深化了XFire和Celtix这两个开发工具。 新产品的退出导致了几个问题。是不是现有的使用Axis 1.x，XFire和Celix的应用需要迁移的新的版本上。如果一个开发人员确定要迁移它的应用到新的框架上，那么他应该选择哪一个呢？相反的，如果一个开发者决定从头开发一个新的Web Service，他应该使用哪个呢？ 这两个框架哪一个更好一些呢？ 对于系统迁移来说，也许迁移到新的框架并不难。Axis和CXF都提供了迁移的指导。能够给开发者一些迁移的技巧和经验。但是对于这样迁移，这两个开源项目都没有提供迁移的工具。对于这样的迁移工作，尽管很值得去寻找所有的可行方案。Axis2和CXF都有各自不同的WebService开发方法，每个方法都有相当数量拥护者。 通过一个比较矩阵来比较Axis2和CXF变得有现实的意义。这两个项目都开发不够成熟，但是最主要的区别在以下几个方面： 1.CXF支持 WS-Addressing，WS-Policy， WS-RM， WS-Security和WS-I Basic Profile。Axis2不支持WS-Policy，但是承诺在下面的版本支持。 CXF可以很好支持Spring。Axis2不能 AXIS2支持更广泛的数据并对，如XMLBeans，JiBX，JaxMe和JaxBRI和它自定义的数据绑定ADB。注意JaxME和JaxBRI都还是试验性的。CXF只支持JAXB和Aegis。在CXF2.1 Axis2支持多语言-除了Java,他还支持C/C++版本。 比较这两个框架的Web Service开发方法与比较它们的特性同样重要。 从开发者的角度，两个框架的特性相当的不同。 Axis2的开发方式类似一个小型的应用服务器，Axis2的开发包要以WAR的形式部署到Servlet容器中，比如Tomcat，通过这些容器可以对工作中的Web Service进行很好的监控和管理。Axis2 的Web administrion模块可以让我们动态的配置Axis2.一个新的服务可以上载，激活，使之失效，修改web服务的参数。管理UI也可以管理一个或者多个处于运行状态的服务。这种界面化管理方式的一个弊端是所有在运行时修改的参数没有办法保存，因为在重启动之后，你所做的修改就会全部失效。 Axis2允许自己作为独立的应用来发布Web Service，并提供了大量的功能和一个很好的模型，这个模型可以通过它本身的架构（modular architecture）不断添加新的功能。有些开发人员认为这种方式对于他们的需求太过于繁琐。这些开发人员会更喜欢CXF。 CXF更注重开发人员的工效（ergonomics）和嵌入能力（embeddability）。大多数配置都可以API来完成，替代了比较繁琐的XML配置文件， Spring的集成性经常的被提及，CXF支持Spring2.0和CXF’s API和Spring的配置文件可以非常好的对应。CXF强调代码优先的设计方式（code-first design)，使用了简单的API使得从现有的应用开发服务变得方便。 不过你选择Axis2还是CXF，你都可以从开源社区得到大量的帮助。这两个框架都有商业公司提供服务，WSO2提供AXIS2的支持，Iona提供CXF的支持。这两公司都有很活跃的开发者社区。 Axis2出现的时间较早，CXF的追赶速度快。我的建议是：如果你需要多语言的支持，你应该选择AXIS2。如果你需要把你的实现侧重JAVA并希望和Spring集成，CXF就是更好的选择，特别是把你的Web Service嵌入其他的程序中。如果你觉得这两个框架的新特性对于你并没有太大的用处，你会觉得Axis1也是不错的选择，你应该继续使用它知道你有充分的理由去更换它。 cxf方式调用webService参考链接：CXF提供Client调用WebService接口的方法 1、 JaxWsProxyFactoryBean 简介： 调用方式采用了和RMI类似的机制，即客户端直接服务器端提供的服务接口(interface),CXF通过运行时代理生成远程服务的代理对象，在客户端完成对webservice的访问; 几个必填的字段：setAddress-这个就是我们发布webservice时候的地址，保持一致 缺点： 这种调用service的好处在于调用过程非常简单，就几行代码就完成一个webservice的调用，但是客户端也必须依赖服务器端的接口，这种调用方式限制是很大的，要求服务器端的webservice必须是java实现–这样也就失去了使用webservice的意义12345678910import org.apache.cxf.jaxws.JaxWsProxyFactoryBean;public class Client &#123; public static void main(String[] args) &#123; JaxWsProxyFactoryBean bean = new JaxWsProxyFactoryBean(); bean.setServiceClass(HelloWorldService.class); bean.setAddress("http://localhost:9090/helloWorldService"); HelloWorldService helloWorldService = (HelloWorldService)bean.create(); String result = helloWorldService.sayHello("Kevin"); System.out.println(result); &#125; 2、 JaxWsDynamicClientFactory [Dynamic：动态的] 简介： 只要指定服务器端wsdl文件的位置，然后指定要调用的方法和方法的参数即可，不关心服务端的实现方式。 wsdl [Web Services Description Language]网络服务描述语言是Web Service的描述语言，它包含一系列描述某个web service的定义123456789import org.apache.cxf.jaxws.endpoint.dynamic.JaxWsDynamicClientFactory;public class Client2 &#123; public static void main(String[] args) throws Exception &#123; JaxWsDynamicClientFactory clientFactory = JaxWsDynamicClientFactory.newInstance(); Client client = clientFactory.createClient("http://localhost:9090/helloWorldService?wsdl"); Object[] result = client.invoke("sayHello", "KEVIN"); System.out.println(result[0]); &#125; &#125; 3、JaxWsServerFactoryBean 用JaxWsServerFactoryBean发布，需要独立的jetty包。]]></content>
      <categories>
        <category>云服务</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[云服务器、vps、虚拟主机的区别]]></title>
    <url>%2F2019%2F05%2F02%2F%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%81vps%E3%80%81%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
    <content type="text"><![CDATA[云服务器Elastic Compute Service, 简称ECS 好多人理解云服务器和VPS一样，更有甚者说以前的VPS现在的说法就是云服务器，其实不然，云服务器是一个计算，网络，存储的组合。简单点说就是通过多个CPU，内存，硬盘组成的计算池和存储池和网络的组合。云服务器就是一些实际的硬件设备，通过虚拟化技术，可以大规模统一调度，并当成“一台”机器的技术。你根本看不到它在哪里，看不到它的CPU、内存、硬盘，但是你可以轻松把它当成“一台”现实中的主机来操作，无论是配置软件、测试性能、还是上传文件都和传统服务器没什么区别。优点：价格适中，使用灵活，高可用性（单个或多个物理离线不会对整个服务造成太大的影响）缺点：性能相对较低阮一峰的解释：“云主机”（Cloud hosting）可以看成是新一代的共享主机。首先，主机公司将它的硬件和网络线路，做成一朵”云”，然后提供一些通向这朵”云”的网络接口API，供客户使用。这时，每个客户共享的不再是某一台特定的服务器，而是云里的所有服务器。一个通俗的比喻是，你可以向银行租一个编号为”8888”的保险箱（共享主机），也可以把贵重物品直接交给保管公司（云主机），听任他们保管。更重要的是云服务器可以动态平衡负载，当你的带宽、内存、硬盘不够用的时候，可以随时点击鼠标增加相应服务，通过弹性的调整，来实现满足各种变化的需求，同时还能控制成本，这就是云服务器最大的卖点。自我理解：云服务器并非服务厂商向用户提供一台固定机器的控制权，可能是一个服务器集群的资源，但是最终可供用户使用的性能指标取决于用户购买云服务器时的性能标准（单核、4g等），服务提供商有技术手段可以限制用户最高只能使用到该性能标准的服务。所以当你购买的云服务器满足不了需求时，可以动态地扩容，购买更高的服务资源性能指标。 vpsVirtual Private Server 虚拟专用服务器,一般是将一个独立服务器通过虚拟化技术虚拟成多个虚拟专用服务器。在物理服务器内通过虚拟化技术，在一套操作系统的技术上，虚拟出很多套的独立运行的操作系统出来，从用户角度来看，就像是有很多台服务器可以使用（其实是运行在同一套物理设备里面）。提高了资源的利用率，共享资源从后降低成本。这一套套虚拟出来的独立的操作系统就是VPS。优点：价格便宜缺点：性能低，高可用性低（除了其所在的物理机出问题了会收到影响，虚拟化技术出问题也会收到影响）。 如何区分云服务器和VPS 既然不是一台真正存在的主机，云服务器是不是和VPS虚拟主机很类似呢？其实不然，VPS是一台真实主机虚拟成多个小主机，性能往往得不到保障，而云服务器是数量庞大的服务器阵列，在均衡负载之后诞生很多虚拟主机，无论是数据安全还是性能都有基本的保证。 可以说云服务器是一种类似VPS服务器的虚拟化技术，VPS是采用虚拟软件，VZ或VM在一台服务器上虚拟出多个类似独立服务器的部分，每个部分都可以做单独的操作系统，管理方法同服务器一样。 云服务器是在一组集群服务器上虚拟出多个类似独立服务器的部分，集群中每个服务器上都有云服务器的一个镜像，从而大大提高了虚拟服务器的安全稳定性，除非所有的集群内服务器全部出现问题，云服务器才会无法访问。 虚拟主机虚拟主机其实是在一套安装好的操作系统上将环境配置好（asp+SQLserver、PHP+MySQL等），然后所有的用户公用一套环境。例如现在新增一个用户，那么虚拟主机管理程序直接在设定的路径新建一个文件件、另外在数据库创建一个子数据库，用户将网页代码通过ftp等方式传送到新建的文件夹内，并将数据存入新建的数据库，整个网站就已经弄好了，域名指向绑带后就可以直接使用了。简单快捷，但是因为是和别人公用一套环境，自由度不高，限制较多，很多人公用后性能也一般。 可以理解为在同一个主机之上运行的多个网址，它们共同占用这台主机的资源。如果同主机上有其他的网站访问量比较大，则其他的网站的性能也会受到影响。 拓展链接：https://www.1deng.me/different-types-of-web-hosting.html]]></content>
      <categories>
        <category>云服务</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SOAP和WSDL的一些必要知识]]></title>
    <url>%2F2019%2F05%2F02%2FSOAP%E5%92%8CWSDL%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%85%E8%A6%81%E7%9F%A5%E8%AF%86.html</url>
    <content type="text"><![CDATA[原文地址：https://www.cnblogs.com/JeffreySun/archive/2009/12/14/1623766.htmlSOAP和WSDL对Web Service、WCF进行深入了解的基础，因此花一些时间去了解一下是很有必要的。 一、SOAP(Simple Object Access Protocol) 如果我们要调用远程对象的方法，就必定要告诉对方，我们要调用的是一个什么方法，以及这个方法的参数的值等等。然后对方把数据返回给我们。 这其中就涉及到两个问题：1、数据如何在网络上传输。2、如何表示数据？用什么格式去表示函数以及它的参数等等。 1、SOAP的传输协议 SOAP的传输协议使用的就是HTTP协议。只不过HTTP传输的内容是HTML文本，而SOAP协议传输的是SOAP的数据。看一下下面的例子： 这是一个HTTP请求(请求google的首页)的内容:12345678GET / HTTP/1.1 Accept: image/gif, image/jpeg, image/pjpeg, image/pjpeg, application/x-shockwave-flash, application/x-ms-application, application/x-ms-xbap, application/vnd.ms-xpsdocument, application/xaml+xml, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/msword, */*Accept-Language: en-usUser-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; CIBA) chromeframe/4.0Accept-Encoding: gzip, deflateConnection: Keep-AliveHost: www.google.comCookie: PREF=ID=d8f9f1710bfa5f72:U=a5b3bec86b6433ef:NW=1:TM=1260238598:LM=1260241971:GM=1:S=q2agYsw3BsoOQMAs; NID=29=JgIGDDUx70IQTBVAnNEP_E9PLLKBI9STjzaBjgq1eWuDg-_jCgFpka59DrOC0aZKLbj4q77HU1VMKscXTP3OaseyTbv643c2XPe9dS7lsXDHAkAnS46vy-OU8XRqbmxJ; rememberme=true; SID=DQAAAH4AAABW7M4nVkTeOR7eJUmC1AJ4R6hYbmVewuy_uItLUTzZMUTpojdaHUExhPa_EPAkO9Ex1u3r7aPXZ5cj28xHnv2DbfRYf5AyaBcimciuOTITKSIkqn3QSpGDFkRS1Xn7EGzDpCV0V1xFlCu0erf_jfe_D6GOgC2P2S08jNdFS9Vpmw; HSID=AFEFTMA68EgNjkbil; __utmx=173272373.; __utmxx=173272373.---------如果有Post的数据，这里还会有Post的数据-------- 这个是一个SOAP请求的内容：12345678910POST /WebServices/WeatherWebService.asmx HTTP/1.1User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; MS Web Services Client Protocol 2.0.50727.3603)Content-Type: text/xml; charset=utf-8SOAPAction: &quot;http://WebXml.com.cn/getSupportCity&quot;Host: www.webxml.com.cnContent-Length: 348Expect: 100-continueConnection: Keep-Alive&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;soap:Envelope xmlns:soap=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;&lt;soap:Body&gt;&lt;getSupportCity xmlns=&quot;http://WebXml.com.cn/&quot;&gt;&lt;byProvinceName&gt;广东&lt;/byProvinceName&gt;&lt;/getSupportCity&gt;&lt;/soap:Body&gt;&lt;/soap:Envelope&gt; 可以看到，一个SOAP请求其实就是一个HTTP请求，但为了表明内容是SOAP的数据，需要加入上面请求中红色字的部分来以示区别。也就是说，如果请求头中有SOAPAction这一段，那么请求会被当作SOAP的内容来处理而不会当作HTML来解析。可以用上面指定SOAPAction头来表示内容是SOAP的内容，也可以指定 Content-Type: application/soap+xml 来表示内容是SOAP的内容。SOAP请求中最后的那段XML数据，这个就是请求的具体内容，这个就是SOAP规定的请求的数据格式，下面再详细对格式进行说明。 2、SOAP的数据格式 现在知道了SOAP是通过HTTP协议的POST方法来传输数据的，只不过是请求的Header中加了一些标志来说明自己是一个SOAP请求。那么数据的具体格式是怎么规定的呢，我们把上面请求的XML数据展开看一下：12345678&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt; &lt;soap:Body&gt; &lt;getSupportCity xmlns="http://WebXml.com.cn/"&gt; &lt;byProvinceName&gt;广东&lt;/byProvinceName&gt; &lt;/getSupportCity&gt; &lt;/soap:Body&gt;&lt;/soap:Envelope&gt; 其中的\soap:Body\里面的内容就是请求的内容，请求的方法为getSupportCity，该方法有一个名为byProvinceName的参数，参数的值为“广东”这个字符串。再看一下返回的内容：1&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;&lt;soap:Body&gt;&lt;getSupportCityResponse xmlns="http://WebXml.com.cn/"&gt;&lt;getSupportCityResult&gt;&lt;string&gt;广州 (59287)&lt;/string&gt;&lt;string&gt;深圳 (59493)&lt;/string&gt;&lt;string&gt;潮州 (59312)&lt;/string&gt;&lt;string&gt;韶关 (59082)&lt;/string&gt;&lt;string&gt;湛江 (59658)&lt;/string&gt;&lt;string&gt;惠州 (59298)&lt;/string&gt;&lt;string&gt;清远 (59280)&lt;/string&gt;&lt;string&gt;东莞 (59289)&lt;/string&gt;&lt;string&gt;江门 (59473)&lt;/string&gt;&lt;string&gt;茂名 (59659)&lt;/string&gt;&lt;string&gt;肇庆 (59278)&lt;/string&gt;&lt;string&gt;汕尾 (59501)&lt;/string&gt;&lt;string&gt;河源 (59293)&lt;/string&gt;&lt;string&gt;揭阳 (59315)&lt;/string&gt;&lt;string&gt;梅州 (59117)&lt;/string&gt;&lt;string&gt;中山 (59485)&lt;/string&gt;&lt;string&gt;德庆 (59269)&lt;/string&gt;&lt;string&gt;阳江 (59663)&lt;/string&gt;&lt;string&gt;云浮 (59471)&lt;/string&gt;&lt;string&gt;珠海 (59488)&lt;/string&gt;&lt;string&gt;汕头 (59316)&lt;/string&gt;&lt;string&gt;佛山 (59279)&lt;/string&gt;&lt;/getSupportCityResult&gt;&lt;/getSupportCityResponse&gt;&lt;/soap:Body&gt;&lt;/soap:Envelope&gt; 返回的HTTP头中并没有标志来表明是一个SOAP的响应，因为的确没有必要，请求方发送出的SOAP请求，返回的肯定是SOAP的响应。 一个典型的SOAP请求格式的结构如下：1234567891011121314151617&lt;?xml version="1.0"?&gt;&lt;soap:Envelope xmlns:soap="http://www.w3.org/2001/12/soap-envelope"soap:encodingStyle="http://www.w3.org/2001/12/soap-encoding"&gt;&lt;soap:Header&gt; &lt;m:Trans xmlns:m="http://www.w3schools.com/transaction/" soap:mustUnderstand="1"&gt;234 &lt;/m:Trans&gt;&lt;/soap:Header&gt;&lt;soap:Body&gt; &lt;m:GetPrice xmlns:m="http://www.w3schools.com/prices"&gt; &lt;m:Item&gt;Apples&lt;/m:Item&gt; &lt;/m:GetPrice&gt;&lt;/soap:Body&gt;&lt;/soap:Envelope&gt; 下面逐个解释里面的元素: a) Envelope SOAP的请求内容必须以Envelope做为根节点。 xmlns:soap=”http://www.w3.org/2001/12/soap-envelope&quot;，不能修改，否则会出错。http://www.w3.org/2001/12/soap-envelope里面有Envelope的schema的相关定义。有兴趣的可以去这个链接的内容。 soap:encodingStyle=”http://www.w3.org/2001/12/soap-encoding&quot;，这个指定了数据元素的类型。 b) Header 这个是可选的，如果需要添加Header元素，那么它必须是Envelope的第一个元素。 Header的内容并没有严格的限制，我们可以自己添加一些和应用程序相关的内容，但是客户端一定要记得处理这些Header元素，可以加上mustUnderstand强制进行处理。 c) Body 这个就是请求的主题内容了，请求什么函数，参数是什么类型等等都在这里面指定。 用标签表示一个函数，然后用子元素表示它的参数。 在调用中没有指定参数和返回类型，这里不需要指定，因为提供服务的一方自己已经规定好了数据类型，在调用时指定数据类型没有任何意义。 二、WSDL(Web Services Description Language) WSDL是用来描述WebService的，它用XML的格式描述了WebService有哪些方法、参数类型、访问路径等等。我们要使用一个WebService肯定首先要获取它的WSDL，在VS中添加一个Web 引用时，这些工作由开发环境帮我们做了，开发环境根据WSDL文档给Web Service生成了相应的代理类供我们使用。 下面是一个HelloWorld的WebService的服务端代码： 1234567891011121314public class Service : System.Web.Services.WebService&#123; public Service () &#123; //Uncomment the following line if using designed components //InitializeComponent(); &#125; [WebMethod] public DateTime HelloWorld(int i) &#123; return DateTime.Now; &#125;&#125; 其对应的WebService的WSDL文档如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;wsdl:definitions xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:tm="http://microsoft.com/wsdl/mime/textMatching/" xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:mime="http://schemas.xmlsoap.org/wsdl/mime/" xmlns:tns="http://tempuri.org/" xmlns:s="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://schemas.xmlsoap.org/wsdl/soap12/" xmlns:http="http://schemas.xmlsoap.org/wsdl/http/" targetNamespace="http://tempuri.org/" xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"&gt; &lt;wsdl:types&gt; &lt;s:schema elementFormDefault="qualified" targetNamespace="http://tempuri.org/"&gt; &lt;s:element name="HelloWorld"&gt; &lt;s:complexType&gt; &lt;s:sequence&gt; &lt;s:element minOccurs="1" maxOccurs="1" name="i" type="s:int" /&gt; &lt;/s:sequence&gt; &lt;/s:complexType&gt; &lt;/s:element&gt; &lt;s:element name="HelloWorldResponse"&gt; &lt;s:complexType&gt; &lt;s:sequence&gt; &lt;s:element minOccurs="1" maxOccurs="1" name="HelloWorldResult" type="s:dateTime" /&gt; &lt;/s:sequence&gt; &lt;/s:complexType&gt; &lt;/s:element&gt; &lt;/s:schema&gt; &lt;/wsdl:types&gt; &lt;wsdl:message name="HelloWorldSoapIn"&gt; &lt;wsdl:part name="parameters" element="tns:HelloWorld" /&gt; &lt;/wsdl:message&gt; &lt;wsdl:message name="HelloWorldSoapOut"&gt; &lt;wsdl:part name="parameters" element="tns:HelloWorldResponse" /&gt; &lt;/wsdl:message&gt; &lt;wsdl:portType name="ServiceSoap"&gt; &lt;wsdl:operation name="HelloWorld"&gt; &lt;wsdl:input message="tns:HelloWorldSoapIn" /&gt; &lt;wsdl:output message="tns:HelloWorldSoapOut" /&gt; &lt;/wsdl:operation&gt; &lt;/wsdl:portType&gt; &lt;wsdl:binding name="ServiceSoap" type="tns:ServiceSoap"&gt; &lt;soap:binding transport="http://schemas.xmlsoap.org/soap/http" /&gt; &lt;wsdl:operation name="HelloWorld"&gt; &lt;soap:operation soapAction="http://tempuri.org/HelloWorld" style="document" /&gt; &lt;wsdl:input&gt; &lt;soap:body use="literal" /&gt; &lt;/wsdl:input&gt; &lt;wsdl:output&gt; &lt;soap:body use="literal" /&gt; &lt;/wsdl:output&gt; &lt;/wsdl:operation&gt; &lt;/wsdl:binding&gt; &lt;wsdl:binding name="ServiceSoap12" type="tns:ServiceSoap"&gt; &lt;soap12:binding transport="http://schemas.xmlsoap.org/soap/http" /&gt; &lt;wsdl:operation name="HelloWorld"&gt; &lt;soap12:operation soapAction="http://tempuri.org/HelloWorld" style="document" /&gt; &lt;wsdl:input&gt; &lt;soap12:body use="literal" /&gt; &lt;/wsdl:input&gt; &lt;wsdl:output&gt; &lt;soap12:body use="literal" /&gt; &lt;/wsdl:output&gt; &lt;/wsdl:operation&gt; &lt;/wsdl:binding&gt; &lt;wsdl:service name="Service"&gt; &lt;wsdl:port name="ServiceSoap" binding="tns:ServiceSoap"&gt; &lt;soap:address location="http://localhost:2206/WebSite1/Service.asmx" /&gt; &lt;/wsdl:port&gt; &lt;wsdl:port name="ServiceSoap12" binding="tns:ServiceSoap12"&gt; &lt;soap12:address location="http://localhost:2206/WebSite1/Service.asmx" /&gt; &lt;/wsdl:port&gt; &lt;/wsdl:service&gt;&lt;/wsdl:definitions&gt; 一个WSDL文档由四部分组成： 1、types 指定了WebService用到的所有数据类型，上面用到了两种数据类型，int和datetime 2、message 指明一个操作所用到的数据类型。 HelloWorldSoapIn是指HelloWorld的输入操作用到的数据类型，HelloWorldSoapOut是指HelloWorld的输出操作用到的数据类型。二者的element元素指出了与types中对应到的具体类型。 3、portType 指出了这个WebService所有支持的操作，就是说有哪些方法可供调用。 这里支持一个HelloWorld调用，它的输入和输出对应到HelloWorldSoapIn和HelloWorldSoapOut这个两个数据类型。 4、binding soap12:binding元素的transport指明传输协议，这里是http协议。 operation 指明要暴露给外界调用的操作。 use属性指定输入输出的编码方式，这里没有指定编码。 5、services 指定服务的一些信息，主要是指定服务的访问路径。]]></content>
      <categories>
        <category>云服务</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[dubbo和zookeeper的关系]]></title>
    <url>%2F2019%2F05%2F02%2Fdubbo%E5%92%8Czookeeper%E7%9A%84%E5%85%B3%E7%B3%BB.html</url>
    <content type="text"><![CDATA[转载前言：网络上很多教程没有描述zookeeper和dubbo到底是什么关系、分别扮演了什么角色等信息，都是说一些似是而非的话，这里终于找到一篇文章，比较生动地描述了注册中心和微服务框架之间的关系，以及他们之间的合作分工。 下面附上我读完之后的理解： dubbo是一个远程调用服务的分布式框架，可以实现远程通讯、动态配置、地址路由等等功能。比如在入门demo里的暴露服务，使得远程调用的协议可以使用dobbo协议(dubbo://x.x.x.x)或者其它协议，可以配置zookeeper集群地址，实现软负载均衡并配置均衡方式等。在不搭配注册中心的时候，它也是可以实现服务端和调用端的通信的，这种方式是点对点通信的，所谓“没有中间商”。但是如果配置服务发布和调用端过多特别是集群的方式提供服务的时候，就会暴露许多的问题：增加节点需要修改配置文件、服务端机器宕机后不能被感知等。 它可以通过集成注册中心，来动态地治理服务发布和服务调用。相当于把服务注册和发布推送的功能分摊给了(zookeeper)注册中心。 原帖地址：https://www.javazhiyin.com/28425.html#m 介绍微服务是最近比较火的概念，而微服务框架目前主流的有Dubbo和Spring Cloud，两者都是为了解决微服务遇到的各种问题而产生的，即遇到的问题是一样的，但是解决的策略却有所不同，所以这2个框架经常拿来比较。没用过Dubbo的小伙伴也不用担心，其实Dubbo还是比较简单的，看完本文你也能掌握一个大概，重要的不是代码，而是思想。 Dubbo实现服务调用是通过RPC的方式，即客户端和服务端共用一个接口(将接口打成一个jar包，在客户端和服务端引入这个jar包)，客户端面向接口写调用，服务端面向接口写实现，中间的网络通信交给框架去实现，想深入了解的看推荐阅读。原文链接有代码GitHub地址 使用入门服务提供者定义服务接口 123public interface DemoService &#123; String sayHello(String name);&#125; 在服务提供方实现接口 123456public class DemoServiceImpl implements DemoService &#123; @Override public String sayHello(String name) &#123; return "Hello " + name; &#125;&#125; 用 Spring 配置声明暴露服务 provider.xml（省略了beans标签的各种属性） 1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans&gt; &lt;!-- 当前项目在整个分布式架构里面的唯一名称，用于计算依赖关系 --&gt; &lt;dubbo:application name="helloworld-app" /&gt; &lt;!--dubbo这个服务所要暴露的服务地址所对应的注册中心，N/A为不使用注册中心--&gt; &lt;dubbo:registry address="N/A"/&gt; &lt;!--当前服务发布所依赖的协议；webserovice、Thrift、Hessain、http--&gt; &lt;dubbo:protocol name="dubbo" port="20880"/&gt; &lt;!--服务发布的配置，需要暴露的服务接口--&gt; &lt;dubbo:service interface="com.st.DemoService" ref="demoService"/&gt; &lt;!--bean的定义--&gt; &lt;bean id="demoService" class="com.st.DemoServiceImpl"/&gt;&lt;/beans&gt; 加载 Spring 配置 12345678public class Provider &#123; public static void main(String[] args) throws Exception &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("provider.xml"); context.start(); System.in.read(); // 按任意键退出 &#125;&#125; 服务消费者consumer.xml 12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans&gt; &lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt; &lt;dubbo:application name="consumer-of-helloworld-app"/&gt; &lt;dubbo:registry address="N/A"/&gt; &lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&gt; &lt;dubbo:reference id="demoService" interface="com.st.DemoService" url="dubbo://localhost:20880/com.st.DemoService"/&gt;&lt;/beans&gt; 加载Spring配置，并调用远程服务 12345678910111213public class Consumer &#123; public static void main(String[] args) throws Exception &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("consumer.xml"); context.start(); // 获取远程服务代理 DemoService demoService = (DemoService)context.getBean("demoService"); // 执行远程方法 String hello = demoService.sayHello("world"); // Hello world System.out.println( hello ); &#125;&#125; 这就是典型的点对点的服务调用。当然我们为了高可用，可以在consumer.xml中配置多个服务提供者，并配置响应的负载均衡策略 配置多个服务调用者在comsumer.xml的dubbo:reference标签的url属性中加入多个地址，中间用分号隔开即可配置负载均衡策略在comsumer.xml的dubbo:reference标签中增加loadbalance属性即可，值可以为如下四种类型 RoundRobin LoadBalance，随机，按权重设置随机概率。 RoundRobin LoadBalance，轮询，按公约后的权重设置轮询比率。 LeastActive LoadBalance，最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。 ConsistentHash LoadBalance，一致性 Hash，相同参数的请求总是发到同一提供者。 12345&lt;dubbo:reference id="demoService" interface="com.st.DemoService" url="dubbo://192.168.11.1:20880/com.st.DemoService; dubbo://192.168.11.2:20880/com.st.DemoService; dubbo://192.168.11.3:20880/com.st.DemoService" loadbalance="roundrobin"/&gt; 现在整体架构是如下图（假设服务消费者为订单服务，服务提供者为用户服务）： 这样会有什么问题呢？ 当服务提供者增加节点时，需要修改配置文件 当其中一个服务提供者宕机时，服务消费者不能及时感知到，还会往宕机的服务发送请求 这个时候就得引入注册中心了 注册中心 Dubbo目前支持4种注册中心,（multicast zookeeper redis simple） 推荐使用Zookeeper注册中心，本文就讲一下用zookeeper实现服务注册和发现（敲黑板，又一种zookeeper的用处），大致流程如下 现在我们来看Dubbo官网对Dubbo的介绍图，有没有和我们上面画的很相似 节点角色说明 节点 角色说明 Provider 暴露服务的服务提供方 Consumer 调用远程服务的服务消费方 Registry 服务注册与发现的注册中心 Monitor 统计服务的调用次数和调用时间的监控中心 Container 服务运行容器 调用关系说明 服务容器负责启动（上面例子为Spring容器），加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 要使用注册中心，只需要将provider.xml和consumer.xml更改为如下 12&lt;!--&lt;dubbo:registry address="N/A"/&gt;--&gt;&lt;dubbo:registry protocol="zookeeper" address="192.168.11.129:2181"/&gt; 如果zookeeper是一个集群，则多个地址之间用逗号分隔即可 1&lt;dubbo:registry protocol="zookeeper" address="192.168.11.129:2181,192.168.11.137:2181,192.168.11.138:2181"/&gt; 把consumer.xml中配置的直连的方式去掉 123456&lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&gt;&lt;!--&lt;dubbo:reference id="demoService" interface="com.st.DemoService"--&gt; &lt;!--url="dubbo://localhost:20880/com.st.DemoService"/&gt;--&gt;&lt;dubbo:reference id="demoService" interface="com.st.DemoService"/&gt; 注册信息在zookeeper中如何保存？ 启动上面服务后，我们观察zookeeper的根节点多了一个dubbo节点及其他，图示如下 最后一个节点中192.168.1.104是小编的内网地址，你可以任务和上面配置的localhost一个效果，大家可以想一下我为什么把最后一个节点标成绿色的。没错，最后一个节点是临时节点，而其他节点是持久节点，这样，当服务宕机时，这个节点就会自动消失，不再提供服务，服务消费者也不会再请求。如果部署多个DemoService，则providers下面会有好几个节点，一个节点保存一个DemoService的服务地址 其实一个zookeeper集群能被多个应用公用，如小编Storm集群和Dubbo配置的就是一个zookeeper集群，为什么呢？因为不同的框架会在zookeeper上建不同的节点，互不影响。如dubbo会创建一个/dubbo节点，storm会创建一个/storm节点，如图 zookeeper相关介绍Zookeeper 是 Apacahe Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为 Dubbo 服务的注册中心，工业强度较高，可用于生产环境，并推荐使用。 流程说明： 服务提供者启动时: 向 /dubbo/com.foo.BarService/providers 目录下写入自己的 URL 地址 服务消费者启动时: 订阅 /dubbo/com.foo.BarService/providers 目录下的提供者 URL 地址。并向 /dubbo/com.foo.BarService/consumers 目录下写入自己的 URL 地址 监控中心启动时: 订阅 /dubbo/com.foo.BarService 目录下的所有提供者和消费者 URL 地址。 支持以下功能： 当提供者出现断电等异常停机时，注册中心能自动删除提供者信息 当注册中心重启时，能自动恢复注册数据，以及订阅请求 当会话过期时，能自动恢复注册数据，以及订阅请求 当设置 &lt;dubbo:registry check=&quot;false&quot; /&gt; 时，记录失败注册和订阅请求，后台定时重试 可通过 &lt;dubbo:registry username=&quot;admin&quot; password=&quot;1234&quot; /&gt; 设置 zookeeper 登录信息 可通过 &lt;dubbo:registry group=&quot;dubbo&quot; /&gt; 设置 zookeeper 的根节点，不设置将使用无根树 支持 * 号通配符 &lt;dubbo:reference group=&quot;*&quot; version=&quot;*&quot; /&gt;，可订阅服务的所有分组和所有版本的提供者 Dubbo相关介绍 Dubbo是什么？ Dubbo是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。简单的说，dubbo就是个服务框架，如果没有分布式的需求，其实是不需要用的，只有在分布式的时候，才有dubbo这样的分布式服务框架的需求，并且本质上是个服务调用的东东，说白了就是个远程服务调用的分布式框架（告别Web Service模式中的WSdl，以服务者与消费者的方式在dubbo上注册）其核心部分包含: 远程通讯: 提供对多种基于长连接的NIO框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。 集群容错: 提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。 自动发现: 基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。 Dubbo能做什么？ 透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。 软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点。 服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。 Dubbo采用全Spring配置方式，透明化接入应用，对应用没有任何API侵入，只需用Spring加载Dubbo的配置即可，Dubbo基于Spring的Schema扩展进行加载。]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[dubbo学习笔记：快速搭建]]></title>
    <url>%2F2019%2F05%2F02%2Fdubbo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA.html</url>
    <content type="text"><![CDATA[搭建一个简单的dubbo服务参考地址： dubbo官网:http://dubbo.apache.org/zh-cn/docs/user/references/registry/zookeeper.html博客:http://www.cnblogs.com/lighten/p/6828026.html 以上两个教程经实践发现都有部分谬误，本教程做了一定更正 1.简介dubbo是一个分布式服务框架，由阿里巴巴的工程师开发，致力于提供高性能和透明化的RPC远程服务调用。可惜的是该项目在2012年之后就没有再更新了，之后由当当基于dubbo开发了dubbox。这里对dubbo的入门构建进行简单的介绍。不涉及dubbo的运行机制，只是搭建过程，方便学习者快速构建项目，运行、熟悉该框架。 dubbo提供了两种构建项目的方法： 通过Spring容器快速构建，其中还有注解的方式； 通过直接使用API（不推荐）。以下对其一一说明。 2.spring配置的形式1.导入maven依赖12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!--如果引入的是2.6.2以下版本，xml文件头引入的xsd地址会报错--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.6.3&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;!-- 排除传递spring依赖 --&gt; &lt;artifactId&gt;spring&lt;/artifactId&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--下面分别是两种不同的zookeeper客户端实现，选择一种就好--&gt;&lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.4&lt;/version&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--后期可能还会用到如下zookeeper客户端jar包依赖，但是目前这个demo不引入也没有问题--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.3.3&lt;/version&gt; &lt;/dependency&gt;&lt;!--spring配置方式，自然需要spring相关的依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;3.2.17.RELEASE&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--打印日志相关--&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.6.4&lt;/version&gt;&lt;/dependency&gt; zkclient和curator curator和zkclient分别为两种不同的zookeeper实现，两者使用的同时都需要开启先zookeeper注册中心的服务端。(关于如何下载配置并启动zookeeper服务端，参考win10环境下搭建zookeeper伪集群)在本项目中，它默认是使用了curator实现的，要改成zkclient实现，需要在&lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181/&quot; client=&quot;zkclient&quot; /&gt;标签中加入 client=&quot;zkclient&quot;，并换成zkclient的依赖。(在dubbo官网中称2.5以上的dubbo版本默认使用zookeeper实现，但是实测结果却相反) 2.定义服务接口(对提供方和调用方都可见)12345package dubboXml;public interface DemoService &#123; String sayHello(String name);&#125; 3.服务提供方配置 实现服务接口 1234567package dubboXml;public class DemoServiceImpl implements DemoService&#123; public String sayHello(String name) &#123; return "Hello " + name; &#125;&#125; spring配置 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://dubbo.apache.org/schema/dubbo" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"&gt; &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt; &lt;dubbo:application name="hello-world-app" /&gt; &lt;!-- 使用zookeeper注册中心暴露服务地址 --&gt; &lt;dubbo:registry address="zookeeper://127.0.0.1:2181" client="zkclient" /&gt; &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt; &lt;dubbo:protocol name="dubbo" port="20880" /&gt; &lt;!-- 声明需要暴露的服务接口 --&gt; &lt;dubbo:service interface="dubboXml.DemoService" ref="demoService" /&gt; &lt;!-- 和本地bean一样实现服务 --&gt; &lt;bean id="demoService" class="dubboXml.DemoServiceImpl" /&gt;&lt;/beans&gt; 读取配置，提供服务 1234567891011package dubboXml;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Provider &#123; public static void main(String[] args) throws Exception &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[] &#123;"provider.xml"&#125;); context.start(); System.in.read(); // 按任意键退出 &#125;&#125; 4.服务调用方配置 spring配置 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://dubbo.apache.org/schema/dubbo" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"&gt; &lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt; &lt;dubbo:application name="consumer-of-helloworld-app" /&gt; &lt;!-- 使用zookeeper注册中心暴露发现服务地址 --&gt; &lt;dubbo:registry address="zookeeper://127.0.0.1:2181" /&gt; &lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&gt; &lt;dubbo:reference id="demoService" interface="dubboXml.DemoService" /&gt;&lt;/beans&gt; 读取配置，调用服务 12345678910111213package dubboXml;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Consumer &#123; public static void main(String[] args) throws Exception &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[] &#123;"consumer.xml"&#125;); context.start(); DemoService demoService = (DemoService)context.getBean("demoService"); // 获取远程服务代理 String hello = demoService.sayHello("nihao"); // 执行远程方法 System.out.println( hello ); // 显示调用结果 &#125;&#125; 最终结果: 5.其他说明 如果涉及传输对象，那么被传输的对象类应该实现serializable接口。因为对象远程传输是以二进制的形式进行的，那么在传输之前需要实现序列化。 我的demo地址:demoXml 我的目录结构: 3.注解配置的方式maven配置同上。 1.服务接口和传输对象服务接口 12345678910package com.common.server;import java.util.List;public interface DemoService &#123; public String greet(String name); public List&lt;User&gt; getUsers();&#125; 传输对象：实现序列化接口 123456789101112131415161718192021222324252627282930313233343536373839404142package com.common.server;import java.io.Serializable;public class User implements Serializable &#123; private static final long serialVersionUID = 1L; private String name; private int age; private String sex; public User(String name, int age, String sex) &#123; this.name = name; this.age = age; this.sex = sex; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; @Override public String toString() &#123; return "User [name=" + name + ", age=" + age + ", sex=" + sex + "]"; &#125;&#125; 2.服务提供方 实现接口(注意加上相应注解) 123456789101112131415161718192021222324252627282930313233343536package com.provider;import com.alibaba.dubbo.config.annotation.Service;import com.common.server.DemoService;import com.common.server.User;import java.util.ArrayList;import java.util.List;/** * 实现类上打上service注解：注意，是dubbo的service注解 */@Servicepublic class DemoServiceImpl implements DemoService &#123; @Override public String greet(String name) &#123; return "Hello " + name; &#125; @Override public List&lt;User&gt; getUsers() &#123; List&lt;User&gt; list = new ArrayList&lt;&gt;(); User user1 = new User("张三",10,"男"); User user2 = new User("李四",11,"女"); User user3 = new User("王五",12,"男"); list.add(user1); list.add(user2); list.add(user3); return list; &#125;&#125; xml配置(与全xml配置服务的方式相比，这里去掉了bean和&lt;dubbo:service&gt;，使用&lt;dubbo:anotition&gt;取代了，相当于自动扫描并暴露服务) 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"&gt; &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt; &lt;dubbo:application name="provider" /&gt; &lt;!-- 使用zookeeper注册中心暴露服务地址 --&gt; &lt;dubbo:registry address="zookeeper://127.0.0.1:2181" client="zkclient" /&gt; &lt;!--&lt;dubbo:registry address="N/A"/&gt;--&gt; &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt; &lt;dubbo:protocol name="dubbo" port="20880" /&gt; &lt;!-- 注解实现，指向服务提供者实现类的包扫描--&gt; &lt;dubbo:annotation package="com.provider" /&gt;&lt;/beans&gt; 开启服务提供 1234567891011121314151617package com.provider;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.io.IOException;/** * 服务提供者 */public class Provider &#123; public static void main(String[] args) throws IOException &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]&#123;"provider.xml"&#125;); context.start(); System.in.read(); &#125;&#125; 3.服务调用方 类中注入并使用远程服务代理（为什么不在加载spring文件的类中注入？因为那是入口) 12345678910111213141516171819202122package com.consumer;import com.alibaba.dubbo.config.annotation.Reference;import com.common.server.DemoService;import org.springframework.stereotype.Component;/** * 服务消费者：service是spring的注解 */@Component("anotationConsumer")public class AnotationConsumer &#123; /** * 远程服务代理，可以和本地bean一样使用demoService */ @Reference(check = false) private DemoService demoService; public void print()&#123; System.out.println(demoService.greet("张三")); System.out.println(demoService.getUsers()); &#125;&#125; consumer.xml spring配置文件 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"&gt; &lt;dubbo:application name="consumer"/&gt; &lt;dubbo:registry address="zookeeper://127.0.0.1:2181" client="zkclient" /&gt; &lt;!--指向服务调用者所在的包--&gt; &lt;dubbo:annotation package="com.consumer" /&gt; &lt;!-- 配置spring注解包扫描 --&gt; &lt;context:component-scan base-package="com.consumer"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 启动服务 1234567891011121314package com.consumer;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Consumer &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]&#123;"consumer.xml"&#125;); context.start(); AnotationConsumer anotationConsumer = (AnotationConsumer) context.getBean("anotationConsumer"); anotationConsumer.print(); &#125;&#125; 调用结果: 4.附加信息 无论是哪种配置方式，如果使用了注册中心，那么注册和调用的时候必须先开启注册中心。 demo地址：dubboAnotation 还有一种api调用的形式，由于不常用所以这里没有提供教程。如果有兴趣可以查看参考帖。]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机网络原理（一）：计算机网络概述]]></title>
    <url>%2F2019%2F05%2F01%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0.html</url>
    <content type="text"><![CDATA[计算机网络概述计算机网络基本概念计算机网络计算机网络是互连的、自治的计算机集合。 协议计算机网络中的实体在进行数据交换的过程中必须遵循的规定或约定，称为网络协议。 协议的三个要素： 语法（定义实体间交换信息的格式和结构，或者定义实体（比如硬件设备）之间传输信号的电平等。 语义（实体间交换的控制信息等） 时序（也称同步，定义实体之间交换信息的顺序以及如何匹配和适应彼此的速度） 计算机网络的功能 硬件功能共享 软件功能共享 信息资源共享 计算机网络的分类 按照覆盖范围 个域网、局域网、城域网、广域网 按拓扑机构分 星形拓扑结构、总线型拓扑结构、环形拓扑结构、网状拓扑结构、树形、混合型 按交换方式分 电报网络交换、报文交换、分组交换 按网络用户属性分 公用网、私有网 计算机网络结构网络边缘各终端 接入网络终端设备和网络核心（网络服务提供商）的连接部分。分为： 电话拨号接入 非对称数字用户线路ADSL 混合光纤同轴电缆HFC接入网络 局域网 移动接入网络 网络核心由通信链路互连的分组交换设备构成的网络，作用是实现网络边缘中主机之间的数据中继和转发。 数据交换技术数据交换的概念通信终端之间通过交换设备进行数据的中继和转发进行数据通信。 1. 电路交换建立电路–&gt;传输数据–&gt;拆除电路 2. 报文交换通过交换节点将整条报文进行中继转发。 3. 分组交换目前广泛采用的互联网通信技术。将报文分割成数据块，每个数据库附上一定的控制信息构成数据分组。每个分组独立传输到目的地，到达后重新组装，还原成报文。 优点 交换设备存储容量要求低 交换速度快 可靠传输率高 更加公平 分组长度的确定略 计算机网络性能1. 速率与带宽基本单位bit/s 2. 时延（延迟） 节点处理时延（传进节点时处理过程） 排队时延 传输时延（传出节点过程） 传播时延 3. 时延带宽积物理链路的传播时延和链路带宽的乘积 4. 丢包率网络拥塞严重时，新到达的分组无法甚至已无缓存空间暂存改分组，此时交换结点会丢弃分组，此所谓“丢包”。 5. 吞吐量理想状况下越等于链路瓶颈的带宽（短板）。 计算机网络体系结构计算机网络分层体系结构将网络功能及其通信协议分层。 OSI参考模型7层。 分别是： 物理层（底层） 在传输介质上实现无结构比特流传输。 规定数据终端设备与数据通信设备之间接口的相关特性，主要包括机械、电气、功能、规程4个方面的特性。 数据链路层 实现在相邻结点之间数据可靠而有效的传输（单位：帧）。 寻址 网络层 解决将分组通过交换网络传送至目的主机，负责转发和路由（单位：数据分组）。 流量控制。 寻址 传输层 第一个端到端的层次，也是进程到进程的层次。 复用/分解、端到端的可靠数据传输传输、连接控制、流量控制和拥塞控制机制。 会话层 对进程之间会话进行管理与控制。 一般被应用层覆盖，很少独立存在。 表示层 处理应用实体之间交换数据的语法，其目的是解决格式和数据表示的差别，从而实现数据能被交换双方所理解。 某些网络中由应用层实现，而且表示层不独立存在。 应用层（顶层） 直接提供给用户以网络服务，包括文件传送、电子邮件、p2p应用等。 为用户提供了一个使用网络应用的接口。 OSI参考模型的7层中，1~3层主要是完成数据交换和数据传输，称之为网络低层；5~7层主要是完成信息处理服务的功能，称之为网络高层；低层与高层之间由第4层衔接。 有关术语数据单元：层之间传送的比特组。服务访问点：相邻层之间，高层可以访问低层的接口。服务原语： 请求：用户实体请求服务做某种工作。 指示：用户实体被告知某件事发生。 响应：用户实体对某件事的响应。 证实：用户实体收到关于它请求的答复。 面向连接的服务： 欲传送数据，先给出对方全称地址，并请求建立连接，对方同意后就建立了通信链路。 传送数据，通常以分组为单位，按序传送，不再标称地址而标称链路号，接收方对成功接收的数据予以确认，称为可靠传输方式。 数据传送结束后，拆除链路。无连接服务：没有建立和拆除链路的过程，每个分组信息带有全称路径，独立选择路径，通常到达的时序也是不确定的，接收之后要重新排序组合。 TCP/IP参考模型4层。 应用层 合并了会话层和表示层 传输层 为进程之间提供逻辑通信 网络互联层 整个参考模型的核心，负责将数据分组发送到目的地。 网络接口层 对应OSI参考模型中的数据链路层和物理层。 五层参考模型基于上两种模型，将表示层和会话层合并到应用层。这是近年来，在描述计算机网络中最常用、最接近实际网络的参考模型。5层分别是： 物理层 数据链路层 网络层 传输层 应用层 基于5层参考模型来描述网络通信的过程，如上图。用户的数据在应用层以报文的形式开始向下一层封装，形成段、数据报、帧，最后以比特流的形式进行传输。在中间节点处，例如路由器、交换机，分别从对应的数据报、帧中取出相应的路由或地址信息并进行处理，并依据转发策略向正确的接口转发数据报或帧。当数据到达目的主机后，自下而上，逐层处理并去掉相应的头部信息，最终还原为最初的报文，交付给用户。]]></content>
      <categories>
        <category>自考</category>
        <category>计算机网络原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机网络原理（二）：网络应用]]></title>
    <url>%2F2019%2F05%2F01%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8.html</url>
    <content type="text"><![CDATA[网络应用计算机网络应用体系结构客户/服务器(c/s)结构网络应用最典型、最基本的网络应用。客户端发送请求，服务器响应请求。 纯P2P结构网络应用端对端的应用，每个对等端同时扮演客户端和服务器的角色。 混合结构网络应用以上两种结构的混合态。 网络应用通信基本原理网络应用的本质是运行在不同的主机上（当然也可运行在同一主机上）的应用之间的通信。进程之间通信并非是高层与高层之间直接通信，而是层层封装，最终形成比特流在物理链路上进行传输。到达目的端的相应层之后，再拆分开来，取出每一层对应的头部信息。两个应用进程看起来就像在直接通信一样，其实并非如此，而是逻辑上可以这样抽象地看待，所以也称为逻辑通信。 域名系统为服务器主机ip地址起的一个更容易读懂和记忆的别名。域名解析就是将这个别名映射为真实的ip地址的过程，实现域名解析需要域名服务器。 层次化域名空间树形结构 域名服务商一个服务器所负责管辖的（或有权限的）范围叫做区。每个区设置相应的权威域名服务器，用来保存该区中所有的主机域名到ip地址的映射。每台主机在进行网络配置时，都会配置一个域名服务器作为默认域名服务器，这个域名服务器被称为本地域名服务器。 根据域名解析过程中的作用和保存的域名信息，可以将域名服务器分为4类： 根域名服务器：最重要的域名服务器。全球13个，知道所有的顶级域名服务器的域名和ip地址，当本地域名服务器无法解析地址，首先请求根域名服务器。顶级域名服务器：对应域名最后一个名字，对一个行业的命名，如com、org等，或对一个区域的命名，如cn、us等。权威域名服务器：负责一个区的域名服务器，任何一个拥有域名的的主机，其域名和ip信息都保存在所在网络的权威域名服务器上。中间域名服务器：不属于前三者。比如www.abc.xyz.com，则com是顶级域名服务器，中间域名服务器xyz.com，权威域名服务器abc.xyz.com。 域名解析过程递归解析和迭代解析：提供递归解析的域名服务器，会进行层层递归查询，将最终的结果返回给查询主机或服务器。提供迭代解析的域名服务器，则会将下一步需要查询的域名服务器信息返回给查询主机和服务器。 通常本地域名服务器都提供递归查询服务。根域名服务器通常只提供迭代查询服务。 为了缓解根域名服务器的压力，通常通过机制来达到： 各域名服务器将每次的结果缓存起来，下次查询到相同的域名时候直接从本机取。 本地域名服务器中存储顶级域名服务器的信息。 万维网应用world wide web.使用超文本传输协议（http）进行数据交互。 Http概述web应用的应用层协议，定义web服务器与客户端如何进行交互。 Http连接http基于传输层的Tcp传输报文。在发送请求之前需要建立tcp连接。 非持久连接 并行连接 持久连接 HTTP报文由起始行、首部行、空白行、实体主题组成。可分为请求报文和响应报文两类。 cookie解决Http无状态的问题。cookie技术包括下面4部分内容： 响应头的set-cookie字段。 客户端本地存储cookie文件。 再次请求时会发送存储的cookie头行。 服务器根据cookie的id维护用户数据。 Internet电子邮件电子邮件系统结构 邮件的发送与接收过程: 用户A首先利用用户代理撰写邮件，包括填写收件人邮箱地址等，然后基于SMTP将邮件发送到其注册的邮件服务器A的外出邮件队列中，等待邮件服务器发送； 邮件服务器A从队列中取出用户A的邮件，基于SMTP发送给邮件服务器B； 邮件服务器B将邮件存放到用户B的邮箱中； 在某个时刻，用户B利用用户代理连接邮件服务器B上运行的邮件读取服务，基于邮件读取协议(POP、IMAP)，将其邮箱中的邮件传输到本地，或者对邮箱中的邮件进行阅读、移动等操作。 用户代理指的是客户端软件 SMTP电子邮件中核心应用层协议，实现邮件服务器之间或客户端到邮件服务器之间的邮件传输。熟知端口号25。 电子邮件格式与MIMEMIME是SMTP的扩展，实现了将非7位ASCII码转换成7位ASCII码文本内容的标准，然后再利用SMTP进行传输。 邮件读取协议POP3、IMAP、HTTP，其中HTTP被用作web mail系统的邮件读取协议。 POP3：最简单的邮件读取协议。熟知端口110。明文传输。下载到客户端本地查看。 IMAP:对服务器远程操作。 HTTP：客户端和邮件服务器之间的交互无论是发送还是接收邮件都是http协议。 FTP文件传送协议。使用两个并行的tcp连接，一个是控制连接（熟知端口21），一个是数据连接（熟知端口20）。 p2p应用优势：每个对等端既是客户端（上传者）又是服务端（下载端），随着对等端的增加几乎不会影响网络性能，而相对的c/s结构的性能瓶颈在于服务器的带宽。 socket编程socket套接字：应用层调用传输层的接口。]]></content>
      <categories>
        <category>自考</category>
        <category>计算机网络原理</category>
      </categories>
  </entry>
</search>
