<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[密码学基础]]></title>
    <url>%2F2019%2F05%2F02%2F%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8.html</url>
    <content type="text"><![CDATA[对称加密和非对称加密参考文章：http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html 对称加密算法 对称密钥加密（英语：Symmetric-key algorithm）又称为对称加密、私钥加密、共享密钥加密，是密码学中的一类加密算法。这类算法在加密和解密时使用相同的密钥，或是使用两个可以简单地相互推算的密钥。实务上，这组密钥成为在两个或多个成员间的共同秘密，以便维持专属的通讯联系。与公开密钥加密相比，要求双方取得相同的密钥是对称密钥加密的主要缺点之一 加密和解密使用的都是相同的密钥，这就导致在多方中只要有一方出现问题泄漏了密钥，那么整个团队就全部沦陷。 常见的对称加密算法有DES、3DES、AES、Blowfish、IDEA、RC5、RC6。 非对称加密算法非对称加密比对称加密更安全，但是相对效率要更低。 公开密钥加密（英语：public-key cryptography，又译为公开密钥加密），也称为非对称加密（asymmetric cryptography），一种密码学算法类型，在这种密码学方法中，需要一对密钥(其实这里密钥说法不好，就是“钥”)，一个是私人密钥，另一个则是公开密钥。这两个密钥是数学相关，用某用户密钥加密后所得的信息，只能用该用户的解密密钥才能解密。如果知道了其中一个，并不能计算出另外一个。因此如果公开了一对密钥中的一个，并不会危害到另外一个的秘密性质。称公开的密钥为公钥；不公开的密钥为私钥。 在双钥体系中，公钥用来加密信息，私钥用来数字签名。 常见的非对称加密算法：RSA、ElGamal、背包算法、Rabin（RSA的特例）、迪菲－赫尔曼密钥交换协议中的公钥加密算法、椭圆曲线加密算法）。 数字签名： 鲍勃有两把钥匙，一把是公钥，另一把是私钥。鲍勃把公钥送给他的朋友们—-帕蒂、道格、苏珊—-每人一把。苏珊要给鲍勃写一封保密的信。她写完后用鲍勃的公钥加密，就可以达到保密的效果。鲍勃收信后，用私钥解密，就看到了信件内容。这里要强调的是，只要鲍勃的私钥不泄露，这封信就是安全的，即使落在别人手里，也无法解密。鲍勃给苏珊回信，决定采用”数字签名“。他写完后先用Hash函数，生成信件的摘要（digest）。鲍勃将这个签名，附在信件下面，一起发给苏珊。苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。 数字证书： 但是并非表示非对称加密就没有安全问题。如果有人冒充公钥的发放者，导致使用者使用冒充的公钥进行加密，那么其加密内容对于冒充者来说，则是完全可见的。 继续上面的故事：复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。此时，苏珊实际拥有的是道格的公钥，但是还以为这是鲍勃的公钥。因此，道格就可以冒充鲍勃，用自己的私钥做成”数字签名”，写信给苏珊，让苏珊用假的鲍勃公钥进行解密。后来，苏珊感觉不对劲，发现自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找”证书中心”（certificate authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成”数字证书“（Digital Certificate）。鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明”数字签名”是否真的是鲍勃签的。 CA的公钥可以用于证明内容发布者的真实身份，被用户持有，称为根证书。 数字签名和证书的另一种表述： 比如在现实生活中，我们想给某个人在网上传送一个机密文件，该文件我们只想让那个人看到，我们设想了很多方法，首先我们想到了用对称密码将文件加密，而在我们把加密后的文件传送给他后，我们又必须得让他知道解密用的密钥，这样就又出现了一个新的问题，就是我们如何保密的传输该密钥，此时我们发现传输对称密钥也不可靠。 后来我们可以改用非对称密码的技术加密，此时发现问题逐渐解决了。然而又有了一个新的问题产生，那就是如何才能确定这个公钥就是某个人的，假如我们得到了一个虚假的公钥，比如说我们想传给A 一个文件，于是开始查找A 的公钥，但是这时B 从中捣乱,他把自己的公钥替换了A 的公钥，让我们错误的认为B 的公钥就是A 的公钥，导致我们最终使用B 的公钥加密文件，结果A 无法打开文件，而B 可以打开文件，这样B 实现了对保密信息的窃取行为。因此就算是采用非对称密码技术，我们仍旧无法保证保密性的实现，那我们如何才能确切的得到我们想要的人的公钥呢？这时我们很自然的想到需要一个仲裁机构，或者说是一个权威的机构，它能为我准确无误的提供我们需要的人的公钥，这就是CA。 这实际上也是应用公钥技术的关键，即如何确认某个人真正拥有公钥（及对应的私钥）。在PKI 中，为了确保用户的身份及他所持有密钥的正确匹配，公开密钥系统需要一个值得信赖而且独立的第三方机构充当认证中心（Certification Authority，CA），来确认公钥拥有人的真正身份。就象公安局发放的身份证一样，认证中心发放一个叫”数字证书”的身份证明。 ​ 这个数字证书包含了用户身份的部分信息及用户所持有的公钥。象公安局对身份证盖章一样，认证中心利用本身的私钥为数字证书加上数字签名。任何想发放自己公钥的用户，可以去认证中心申请自己的证书。认证中心在鉴定该人的真实身份后，颁发包含用户公钥的数字证书。其他用户只要能验证证书是真实的，并且信任颁发证书的认证中心，就可以确认用户的公钥。认证中心是公钥基础设施的核心，有了大家信任的认证中心，用户才能放心方便的使用公钥技术带来的安全服务。 数字证书在网络中的典型应用：https协议 这个协议主要用于网页加密。 1、首先，客户端向服务器发出加密请求。 2、服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。 3、客户端（浏览器）的”证书管理器”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。 4、如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。 5、如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。 6、如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息。 总结： 数字证书是在数字签名的基础上，加上第三方机构公证，以证明内容发布者的身份。前提是要保证这个第三方机构是可靠的。]]></content>
      <categories>
        <category>信息安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[oracle执行计划]]></title>
    <url>%2F2019%2F05%2F02%2Foracle%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92.html</url>
    <content type="text"><![CDATA[执行计划参考地址： https://www.cnblogs.com/Dreamer-1/p/6076440.html(主要) https://cloud.tencent.com/developer/article/1033609 本文在主要参考连接的博客内容上用markdown重排了部分格式，并加上了部分理解和实例解析。第二个参考博客主要是加深了对执行计划的部分理解。对此表示感谢。 什么是Oracle执行计划？执行计划是一条查询语句在Oracle中的执行步骤或访问路径的描述。 怎样查看Oracle执行计划？这里以PLSQL为例： 配置执行计划需要显示的项： 工具 —&gt; 首选项 —&gt; 窗口类型 —&gt; 计划窗口 —&gt; 根据需要配置要显示在执行计划中的列 执行计划的常用列字段解释： 基数（Rows）：Oracle估计的当前操作的返回结果集行数 字节（Bytes）：执行该步骤后返回的字节数 耗费（COST）、CPU耗费：Oracle估计的该步骤的执行成本，用于说明SQL执行的代价，理论上越小越好（该值可能与实际有出入） 时间（Time）：Oracle估计的当前操作所需的时间 打开执行计划： 在SQL窗口执行完一条select语句后按 F5 即可查看刚刚执行的这条查询语句的执行计划 注：在PLSQL中使用SQL命令查看执行计划的话，某些SQL*PLUS命令PLSQL无法支持，比如SET AUTOTRACE ON 看懂Oracle执行计划 执行顺序： 根据Operation缩进来判断，缩进最多的最先执行；（缩进相同时，最上面的最先执行） 例：上图中 INDEX RANGE SCAN 和 INDEX UNIQUE SCAN 两个动作缩进最多，最上面的 INDEX RANGE SCAN 先执行； 同一级如果某个动作没有子ID就最先执行（除了最先执行的那个动作外） 同一级的动作执行时遵循最上最右先执行的原则 例：上图中 TABLE ACCESS BY GLOBAL INDEX ROWID 和 TABLE ACCESS BY INDEX ROWID 两个动作缩进都在同一级，则位于上面的 TABLE ACCESS BY GLOBAL INDEX ROWID 这个动作先执行；这个动作又包含一个子动作 INDEX RANGE SCAN，则位于右边的子动作 INDEX RANGE SCAN 先执行； 图示中的SQL执行顺序即为： INDEX RANGE SCAN —&gt; TABLE ACCESS BY GLOBAL INDEX ROWID —&gt; INDEX UNIQUE SCAN —&gt; TABLE ACCESS BY INDEX ROWID —&gt; NESTED LOOPS OUTER —&gt; SORT GROUP BY —&gt; SELECT STATEMENT, GOAL = ALL_ROWS （ 注：PLSQL提供了查看执行顺序的功能按钮(上图中的红框部分) ） 1、先确定最深层的连接是哪一级（INDEX RANGE SCAN 和 INDEX UNIQUE SCAN这一级）2、从上往下数的第一个最深层的子动作先执行（INDEX RANGE SCAN）3、由内而外（TABLE ACCESS BY GLOBAL INDEX ROWID）…4、直到有兄弟节点（TABLE ACCESS BY INDEX ROWID），则从下一个兄弟节点内部开始按照以上1~3的顺序执行。5、直到执行完毕 对图中动作的一些说明： 上图中 TABLE ACCESS BY … 即描述的是该动作执行时表访问（或者说Oracle访问数据）的方式； 表访问的几种方式：（非全部） TABLE ACCESS FULL（全表扫描） TABLE ACCESS BY ROWID（通过ROWID的表存取） TABLE ACCESS BY INDEX SCAN（索引扫描） TABLE ACCESS BY INDEX ROWID (根据索引找到rowid，再通过rowid定位到行数据) （1） TABLE ACCESS FULL（全表扫描）： Oracle会读取表中所有的行，并检查每一行是否满足SQL语句中的 Where 限制条件； 全表扫描时可以使用多块读（即一次I/O读取多块数据块）操作，提升吞吐量； 使用建议：数据量太大的表不建议使用全表扫描，除非本身需要取出的数据较多，占到表数据总量的 5% ~ 10% 或以上 （2） TABLE ACCESS BY ROWID（通过ROWID的表存取） : 先说一下什么是ROWID？ ROWID是由Oracle自动加在表中每行最后的一列伪列，既然是伪列，就说明表中并不会物理存储ROWID的值； 你可以像使用其它列一样使用它，只是不能对该列的值进行增、删、改操作； 一旦一行数据插入后，则其对应的ROWID在该行的生命周期内是唯一的，即使发生行迁移，该行的ROWID值也不变。 让我们再回到 TABLE ACCESS BY ROWID 来： 行的ROWID指出了该行所在的数据文件、数据块以及行在该块中的位置，所以通过ROWID可以快速定位到目标数据上，这也是Oracle中存取单行数据最快的方法； （3） TABLE ACCESS BY INDEX SCAN（索引扫描）： 在索引块中，既存储每个索引的键值，也存储具有该键值的行的ROWID。 一个数字列上建索引后该索引可能的概念结构如下图： 所以索引扫描其实分为两步： Ⅰ：扫描索引得到对应的ROWID Ⅱ：通过ROWID定位到具体的行读取数据 —————-索引扫描延伸——————- 索引扫描又分五种： INDEX UNIQUE SCAN（索引唯一扫描） INDEX RANGE SCAN（索引范围扫描） INDEX FULL SCAN（索引全扫描） INDEX FAST FULL SCAN（索引快速扫描） INDEX SKIP SCAN（索引跳跃扫描) a) INDEX UNIQUE SCAN（索引唯一扫描）： 针对唯一性索引（UNIQUE INDEX）的扫描，每次至多只返回一条记录； 表中某字段存在 UNIQUE、PRIMARY KEY 约束时，Oracle常实现唯一性扫描； b) INDEX RANGE SCAN（索引范围扫描）： 使用一个索引存取多行数据； 发生索引范围扫描的三种情况： 在唯一索引列上使用了范围操作符（如：&gt; &lt; &lt;&gt; &gt;= &lt;= between） 在组合索引上，只使用部分列进行查询（查询时必须包含前导列，否则会走全表扫描） 对非唯一索引列上进行的任何查询 c) INDEX FULL SCAN（索引全扫描）： 进行全索引扫描时，查询出的数据都必须从索引中可以直接得到（注意全索引扫描只有在CBO模式下才有效） ———————– 延伸阅读：Oracle优化器简述 ———————– Oracle中的优化器是SQL分析和执行的优化工具，它负责生成、制定SQL的执行计划。 Oracle的优化器有两种： RBO（Rule-Based Optimization） 基于规则的优化器 CBO（Cost-Based Optimization） 基于代价的优化器 RBO： RBO有严格的使用规则，只要按照这套规则去写SQL语句，无论数据表中的内容怎样，也不会影响到你的执行计划； 换句话说，RBO对数据“不敏感”，它要求SQL编写人员必须要了解各项细则； RBO一直沿用至ORACLE 9i，从ORACLE 10g开始，RBO已经彻底被抛弃。 CBO： CBO是一种比RBO更加合理、可靠的优化器，在ORACLE 10g中完全取代RBO； CBO通过计算各种可能的执行计划的“代价”，即COST，从中选用COST最低的执行方案作为实际运行方案； 它依赖数据库对象的统计信息，统计信息的准确与否会影响CBO做出最优的选择，也就是对数据“敏感”。 ——————————————————– d) INDEX FAST FULL SCAN（索引快速扫描）: 扫描索引中的所有的数据块，与 INDEX FULL SCAN 类似，但是一个显著的区别是它不对查询出的数据进行排序（即数据不是以排序顺序被返回） e) INDEX SKIP SCAN（索引跳跃扫描）： Oracle 9i后提供，有时候复合索引的前导列（索引包含的第一列）没有在查询语句中出现，oralce也会使用该复合索引，这时候就使用的INDEX SKIP SCAN; 什么时候会触发 INDEX SKIP SCAN 呢？ 前提条件：表有一个复合索引，且在查询时有除了前导列（索引中第一列）外的其他列作为条件，并且优化器模式为CBO时 当Oracle发现前导列的唯一值个数很少时，会将每个唯一值都作为常规扫描的入口，在此基础上做一次查找，最后合并这些查询； 例如： 假设表emp有ename（雇员名称）、job（职位名）、sex（性别）三个字段，并且建立了如 create index idx_emp on emp (sex, ename, job) 的复合索引； 因为性别只有 ‘男’ 和 ‘女’ 两个值，所以为了提高索引的利用率，Oracle可将这个复合索引拆成 (‘男’, ename, job)，(‘女’, ename, job) 这两个复合索引； 当查询 select * from emp where job = ‘Programmer’ 时，该查询发出后： Oracle先进入sex为’男’的入口，这时候使用到了 (‘男’, ename, job) 这条复合索引，查找 job = ‘Programmer’ 的条目； 再进入sex为’女’的入口，这时候使用到了 (‘女’, ename, job) 这条复合索引，查找 job = ‘Programmer’ 的条目； 最后合并查询到的来自两个入口的结果集。 ———————————————- 上图中的 NESTED LOOPS … 描述的是表连接方式； JOIN 关键字用于将两张表作连接，一次只能连接两张表，JOIN 操作的各步骤一般是串行的（在读取做连接的两张表的数据时可以并行读取）； 表（row source）之间的连接顺序对于查询效率有很大的影响，对首先存取的表（驱动表）先应用某些限制条件（Where过滤条件）以得到一个较小的row source，可以使得连接效率提高。 ————————-延伸阅读：驱动表（Driving Table）与匹配表（Probed Table）————————- 驱动表（Driving Table）： 表连接时首先存取的表，又称外层表（Outer Table），这个概念用于 NESTED LOOPS（嵌套循环） 与 HASH JOIN（哈希连接）中； 如果驱动表返回较多的行数据，则对所有的后续操作有负面影响，故一般选择小表（应用Where限制条件后返回较少行数的表）作为驱动表。 匹配表（Probed Table）： 又称为内层表（Inner Table），从驱动表获取一行具体数据后，会到该表中寻找符合连接条件的行。故该表一般为大表（应用Where限制条件后返回较多行数的表）。 ——————————————————————————————————— 表连接的几种方式： SORT MERGE JOIN（排序-合并连接） NESTED LOOPS（嵌套循环） HASH JOIN（哈希连接） CARTESIAN PRODUCT（笛卡尔积） 注：这里将首先存取的表称作 row source 1，将之后参与连接的表称作 row source 2； （1） SORT MERGE JOIN（排序-合并连接）： 假设有查询：select a.name, b.name from table_A a join table_B b on (a.id = b.id) 内部连接过程： a) 生成 row source 1 需要的数据，按照连接操作关联列（如示例中的a.id）对这些数据进行排序 b) 生成 row source 2 需要的数据，按照与 a) 中对应的连接操作关联列（b.id）对数据进行排序 c) 两边已排序的行放在一起执行合并操作（对两边的数据集进行扫描并判断是否连接） 延伸： 如果示例中的连接操作关联列 a.id，b.id 之前就已经被排过序了的话，连接速度便可大大提高，因为排序是很费时间和资源的操作，尤其对于有大量数据的表。 故可以考虑在 a.id，b.id 上建立索引让其能预先排好序。不过遗憾的是，由于返回的结果集中包括所有字段，所以通常的执行计划中，即使连接列存在索引，也不会进入到执行计划中，除非进行一些特定列处理（如仅仅只查询有索引的列等）。 排序-合并连接的表无驱动顺序，谁在前面都可以； 排序-合并连接适用的连接条件有： &lt; &lt;= = &gt; &gt;= ，不适用的连接条件有： &lt;&gt; like （2） NESTED LOOPS（嵌套循环）： 内部连接过程： a) 取出 row source 1 的 row 1（第一行数据），遍历 row source 2 的所有行并检查是否有匹配的，取出匹配的行放入结果集中 b) 取出 row source 1 的 row 2（第二行数据），遍历 row source 2 的所有行并检查是否有匹配的，取出匹配的行放入结果集中 c) …… 若 row source 1 （即驱动表）中返回了 N 行数据，则 row source 2 也相应的会被全表遍历 N 次。 因为 row source 1 的每一行都会去匹配 row source 2 的所有行，所以当 row source 1 返回的行数尽可能少并且能高效访问 row source 2（如建立适当的索引）时，效率较高。 延伸： 嵌套循环的表有驱动顺序，注意选择合适的驱动表。 嵌套循环连接有一个其他连接方式没有的好处是：可以先返回已经连接的行，而不必等所有的连接操作处理完才返回数据，这样可以实现快速响应。 应尽可能使用限制条件（Where过滤条件）使驱动表（row source 1）返回的行数尽可能少，同时在匹配表（row source 2）的连接操作关联列上建立唯一索引（UNIQUE INDEX）或是选择性较好的非唯一索引，此时嵌套循环连接的执行效率会变得很高。若驱动表返回的行数较多，即使匹配表连接操作关联列上存在索引，连接效率也不会很高。 （3）HASH JOIN（哈希连接） : 哈希连接只适用于等值连接（即连接条件为 = ） HASH JOIN对两个表做连接时并不一定是都进行全表扫描，其并不限制表访问方式； 内部连接过程简述： a) 取出 row source 1（驱动表，在HASH JOIN中又称为Build Table） 的数据集，然后将其构建成内存中的一个 Hash Table（Hash函数的Hash KEY就是连接操作关联列），创建Hash位图（bitmap） b) 取出 row source 2（匹配表）的数据集，对其中的每一条数据的连接操作关联列使用相同的Hash函数并找到对应的 a) 里的数据在 Hash Table 中的位置，在该位置上检查能否找到匹配的数据 —————-延伸阅读：Hash Table相关—————- 来自Wiki的解释： In computing, a hash table (hash map) is a data structure used to implement an associative array, a structure that can map keys to values. A hash table uses a hash function to compute an index into an array of buckets or slots, from which the desired value can be found. 散列（hash）技术：在记录的存储位置和记录具有的关键字key之间建立一个对应关系 f ，使得输入key后，可以得到对应的存储位置 f(key)，这个对应关系 f 就是散列（哈希）函数； 采用散列技术将记录存储在一块连续的存储空间中，这块连续的存储空间就是散列表（哈希表）； 不同的key经同一散列函数散列后得到的散列值理论上应该不同，但是实际中有可能相同，相同时即是发生了散列（哈希）冲突，解决散列冲突的办法有很多，比如HashMap中就是用链地址法来解决哈希冲突； 哈希表是一种面向查找的数据结构，在输入给定值后查找给定值对应的记录在表中的位置以获取特定记录这个过程的速度很快。 ——————————————————– HASH JOIN的三种模式： OPTIMAL HASH JOIN ONEPASS HASH JOIN MULTIPASS HASH JOIN 1) OPTIMAL HASH JOIN： OPTIMAL 模式是从驱动表（也称Build Table）上获取的结果集比较小，可以把根据结果集构建的整个Hash Table都建立在用户可以使用的内存区域里。 连接过程简述： Ⅰ：首先对Build Table内各行数据的连接操作关联列使用Hash函数，把Build Table的结果集构建成内存中的Hash Table。如图所示，可以把Hash Table看作内存中的一块大的方形区域，里面有很多的小格子，Build Table里的数据就分散分布在这些小格子中，而这些小格子就是Hash Bucket（见上面Wiki的定义）。 Ⅱ：开始读取匹配表（Probed Table）的数据，对其中每行数据的连接操作关联列都使用同上的Hash函数，定位Build Table里使用Hash函数后具有相同值数据所在的Hash Bucket。 Ⅲ：定位到具体的Hash Bucket后，先检查Bucket里是否有数据，没有的话就马上丢掉匹配表（Probed Table）的这一行。如果里面有数据，则继续检查里面的数据（驱动表的数据）是否和匹配表的数据相匹配。 2): ONEPASS HASH JOIN : 从驱动表（也称Build Table）上获取的结果集较大，无法将根据结果集构建的Hash Table全部放入内存中时，会使用 ONEPASS 模式。 连接过程简述： Ⅰ：对Build Table内各行数据的连接操作关联列使用Hash函数，根据Build Table的结果集构建Hash Table后，由于内存无法放下所有的Hash Table内容，将导致有的Hash Bucket放在内存里，有的Hash Bucket放在磁盘上，无论放在内存里还是磁盘里，Oracle都使用一个Bitmap结构来反映这些Hash Bucket的状态（包括其位置和是否有数据）。 Ⅱ：读取匹配表数据并对每行的连接操作关联列使用同上的Hash函数，定位Bitmap上Build Table里使用Hash函数后具有相同值数据所在的Bucket。如果该Bucket为空，则丢弃匹配表的这条数据。如果不为空，则需要看该Bucket是在内存里还是在磁盘上。 如果在内存中，就直接访问这个Bucket并检查其中的数据是否匹配，有匹配的话就返回这条查询结果。 如果在磁盘上，就先把这条待匹配数据放到一边，将其先暂存在内存里，等以后积累了一定量的这样的待匹配数据后，再批量的把这些数据写入到磁盘上（上图中的 Dump probe partitions to disk）。 Ⅲ：当把匹配表完整的扫描了一遍后，可能已经返回了一部分匹配的数据了。接下来还有Hash Table中一部分在磁盘上的Hash Bucket数据以及匹配表中部分被写入到磁盘上的待匹配数据未处理，现在Oracle会把磁盘上的这两部分数据重新匹配一次，然后返回最终的查询结果。 3): MULTIPASS HASH JOIN： 当内存特别小或者相对而言Hash Table的数据特别大时，会使用 MULTIPASS 模式。MULTIPASS会多次读取磁盘数据，应尽量避免使用该模式。 上图中的 … OUTER 描述的是表连接类型； 表连接的两种类型： INNER JOIN（内连接） OUTER JOIN（外连接） 示例数据说明： 现有A、B两表，A表信息如下： B表信息如下： ![](https://images2015.cnblogs.com/blog/946400/201611/946400-20161118093815045-506270202.png) 下面的例子都用A、B两表来演示。 &lt;br&gt; （1） **INNER JOIN（内连接）**： **只返回两表中相匹配的记录**。 INNER JOIN 又分为两种： - 等值连接（连接条件为 **=** ） - 非等值连接（连接条件为 **非 =** ，如 **&gt; &gt;= &lt; &lt;=** 等） 等值连接用的最多，下面以等值连接举例： 内连接的两种写法： Ⅰ： select a.id A_ID, a.name A_NAME, b.id B_ID, b.name B_NAME from A a inner join B b on (a.id = b.id) Ⅱ： select a.id A_ID, a.name A_NAME, b.id B_ID, b.name B_NAME from A a join B b on (a.id = b.id) 连接时只返回满足连接条件（a.id = b.id）的记录： ![](https://images2015.cnblogs.com/blog/946400/201611/946400-20161118093815873-1852639824.png) &lt;br&gt; （2） **OUTER JOIN（外连接）**： OUTER JOIN 分为三种： - LEFT OUTER JOIN（可简写为 LEFT JOIN，左外连接） - RIGHT OUTER JOIN（ RIGHT JOIN，右外连接） - FULL OUTER JOIN（ FULL JOIN，全外连接） a) **LEFT JOIN（左连接）**： **返回的结果不仅包含符合连接条件的记录，还包含左边表中的全部记录**。（若返回的左表中某行记录在右表中没有匹配项，则右表中的返回列均为空值） 两种写法： Ⅰ：select a.id A_ID, a.name A_NAME, b.id B_ID, b.name B_NAME from A a left outer join B b on (a.id = b.id) Ⅱ：select a.id A_ID, a.name A_NAME, b.id B_ID, b.name B_NAME from A a left join B b on (a.id = b.id) 返回结果： ![](https://images2015.cnblogs.com/blog/946400/201611/946400-20161118093816670-1364160488.png) b) **RIGHT JOIN（右连接）**： **返回的结果不仅包含符合连接条件的记录，还包含右边表中的全部记录**。（若返回的右表中某行记录在左表中没有匹配项，则左表中的返回列均为空值） 两种写法： Ⅰ：select a.id A_ID, a.name A_NAME, b.id B_ID, b.name B_NAME from A a right outer join B b on (a.id = b.id) Ⅱ：select a.id A_ID, a.name A_NAME, b.id B_ID, b.name B_NAME from A a right join B b on (a.id = b.id) 返回结果： ![](https://images2015.cnblogs.com/blog/946400/201611/946400-20161118093817638-188208673.png) c) **FULL JOIN（全连接）**： **返回左右两表的全部记录**。(左右两边不匹配的项都以空值代替) 两种写法： Ⅰ：select a.id A_ID, a.name A_NAME, b.id B_ID, b.name B_NAME from A a full outer join B b on (a.id = b.id) Ⅱ：select a.id A_ID, a.name A_NAME, b.id B_ID, b.name B_NAME from A a full join B b on (a.id = b.id) 返回结果： ![full_join](https://images2015.cnblogs.com/blog/946400/201611/946400-20161118093818435-1120340523.png) &lt;br&gt; &lt;font color=&quot;red&quot;&gt;---------------------延伸阅读： (+) 操作符-------------------&lt;/font&gt; (+) 操作符是Oracle特有的表示法，用来表示外连接（只能表示 左外、右外 连接），需要配合Where语句使用。 特别注意：**(+) 操作符在左表的连接条件上表示右连接，在右表的连接条件上表示左连接**。 如： Ⅰ：select a.id A_ID, a.name A_NAME, b.id B_ID, b.name B_NAME from A a, B b where a.id = b.id(+) 查询结果： ![](https://images2015.cnblogs.com/blog/946400/201611/946400-20161118093819201-316738855.png) 实际与**左连接** select a.id A_ID, a.name A_NAME, b.id B_ID, b.name B_NAME from A a left join B b on (a.id = b.id) 效果等价 Ⅱ：select a.id A_ID, a.name A_NAME, b.id B_ID, b.name B_NAME from A a, B b where a.id(+) = b.id 查询结果： ![](https://images2015.cnblogs.com/blog/946400/201611/946400-20161118093819967-1532236604.png) 实际与**右连接** select a.id A_ID, a.name A_NAME, b.id B_ID, b.name B_NAME from A a right join B b on (a.id = b.id) 效果等价 &lt;font color=&quot;red&quot;&gt;----------------------------------------------------------&lt;/font&gt; &lt;br&gt; 补充： 自连接（通过给一个表赋两个不同的别名让其与自身内连或外连接） 结合实例分析一、NESTED LOOPS 1SELECT * FROM emp, dept WHERE emp.empno=dept.deptno 执行计划分析： 首先对dept表进行全表扫描(TABLE ACCESS FULL)，并对emp表进行唯一索引扫描(INDEX UNIQUE SCAN)，再对两表的结果进行嵌套循环(NESTED LOOPS)方式的连接。 那么驱动表是哪个呢？因为是上面的TABLE ACCESS FULL操作先执行，那么应该是首先查询的dept表作为驱动表，并用其每一行在emp表中进行循环匹配。dept表查询为什么没用deptno列索引，因为select *需要查询到两表所有字段，而索引中只有deptno字段的数据，所以直接全表查询。 至于为什么emp表用了UNIQUE索引扫描，那时因为它作为内层表要被多次循环匹配，用索引当然是为了提高效率。 从1中，我们得到了dept表的符合匹配条件的所有字段+emp表的empno字段，而select *是为了查询到两表所有的字段数据，那么接下来就是再次把 第1步的结果集作为驱动表去匹配emp表（TABLE ACCESS BY INDEX ROWID），所以我们可以看到外层还有一个NESTED LOOPS连接。 TABLE ACCESS BY INDEX ROWID是用来查询emp表数据的一种方式，因为索引中存放的是索引键值和rowid，所以这种方式就是通过索引键值匹配的rowid，定位到这一行数据，再把整行的数据（包括索引列和其他所有列的数据）取出来的。 二、MERGE JOIN 12-- 注意，和上面的语句有点不一样！！SELECT * FROM dept d, emp e WHERE d.deptno=e.deptno 先对dept进行全索引扫描(INDEX FULL SCAN)，并根据索引deptno对应的rowid找到整行数据(TABLE ACCESS BY INDEX ROWID)。 对emp进行全表扫描(TABLE ACCESS FULL)，并进行排序（因为emp表的匹配字段deptno没有索引）TABLE ACCESS FULL 两表数据数据进行合并 MERGE JOIN]]></content>
      <categories>
        <category>数据库</category>
        <category>oracle</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[中间件基本概念]]></title>
    <url>%2F2019%2F05%2F02%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html</url>
    <content type="text"><![CDATA[中间件：个人理解，早期WEB项目采用MVC架构，全靠一台服务器扛起来的，随着互联发发展，服务器压力越来越大，分布式框架被大量的运用在B2C等项目中，比如面相服务的SOA架构，所采用的方式就是将各个业务系统拆分开来，独自承担压力，这样的架构就保证了项目的高可用。那么问题也随之而来，各个服务间如何进行通信，使用点对点的方式后期发现调用易造成混乱，所以可以采用这个面相服务治理的中间件Dubbo。嘿嘿，那么中间件到底是干嘛的其实根据上面来说能够稍微知道一点，其实就好像上面大家说的，中间件跟业务无关，仅仅在做各个服务中连接问题，好像一个路由器一样，将所有的子系统统一管理，从dubbo的核心RPC和NIO也能看出来，主要还是在负责服务间连接通信。还有就是它要去使用还需要依赖一个注册中心，官方推荐Zookeeper，我的理解就是dubbo负责连接（就是用自己的方案来获取provider和customer的url）集中交给zookeeper注册中间统一管理。这样我们在调用服务的时候，只需要通过中间件，就可以完成。这样做的好处就是可以让我们不论是前端和后端人员，可以在大型的分布式系统中专注于自身业务即可 作者：(知乎)哈里亮链接 下面是oracle官方的解释：由于业务、机构和技术是不断变化的，因此为其服务的软件系统必须适应这样的变化。在合并、添加服务或扩展可用服务之后，公司可能无力负担重新创建信息系统所需的成本。正是在这个关键时刻，才需要集成新组件或者尽可能高效地扩展现有组件。要集成异类组件，最方便的方法不是将它们重新创建为同类元素，而是提供一个允许它们进行通信（不考虑它们之间的差异）的层。该层被称作中间件，它允许独立开发且运行于不同网络平台上的软件组件（应用程序、Enterprise Java Bean、Servlet 和其他组件）彼此交互。当能够进行这样的交互时，网络才成为计算机。原文地址：原文链接 自己概括一下：中间件就是对服务组件之间进行相互关联和通信的非业务性的组件。]]></content>
      <categories>
        <category>中间件</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[webService基本概念、元素及简单编码实现]]></title>
    <url>%2F2019%2F05%2F02%2FwebService%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E3%80%81%E5%85%83%E7%B4%A0%E5%8F%8A%E7%AE%80%E5%8D%95%E7%BC%96%E7%A0%81%E5%AE%9E%E7%8E%B0.html</url>
    <content type="text"><![CDATA[webService“网络服务”（Web Service）的本质，就是通过网络调用其他网站的资源。网络服务是相对于本地服务来说的，本机完成本机需要完成的任务，叫“本地服务”，而“网络服务”则是通过网络来调用其他服务器提供的服务。 webService和中间件的关系：webService是一种技术手段，是一种网络中系统之间进行交互的方式。而中间件则是实现这种交互的一种手段（一种软件、服务）。 定义：WebService是一种跨编程语言和跨操作系统平台的远程调用技术（rpc）。实现平台无关性和语言无关性的关键是用一种标准来统一定义相互通信的接口，而WebService平台技术就是旨在解决统一标准的问题。引用：Web service是什么？ WebService平台技术XML+XSD,SOAP和WSDL就是构成WebService平台的三大技术。SOAP和WSDL的详细格式和解析可见：SOAP和WSDL的一些必要知识 or 备用地址 XML和XSD： WebService采用HTTP协议传输数据，采用XML格式封装数据（即XML中说明调用远程服务对象的哪个方法，传递的参数是什么，以及服务对象的返回结果是什么）。XML是WebService平台中表示数据的格式。除了易于建立和易于分析外，XML主要的优点在于它既是平台无关的，又是厂商无关的。无关性是比技术优越性更重要的：软件厂商是不会选择一个由竞争对手所发明的技术的。XML解决了数据表示的问题，但它没有定义一套标准的数据类型，更没有说怎么去扩展这套数据类型。例如，整形数到底代表什么？16位，32位，64位？这些细节对实现互操作性很重要。XML Schema(XSD)就是专门解决这个问题的一套标准。它定义了一套标准的数据类型，并给出了一种语言来扩展这套数据类型。WebService平台就是用XSD来作为其数据类型系统的。当你用某种语言(如VB.NET或C#)来构造一个Web service时，为了符合WebService标准，所有你使用的数据类型都必须被转换为XSD类型。你用的工具可能已经自动帮你完成了这个转换，但你很可能会根据你的需要修改一下转换过程。 xsd就是基于xml，自己定义了一套标签，用来对webService中的数据表示格式进一步规范。 SOAP： WebService通过HTTP协议发送请求和接收结果时，发送的请求内容和结果内容都采用XML格式封装，并增加了一些特定的HTTP消息头，以说明HTTP消息的内容格式，这些特定的HTTP消息头和XML内容格式就是SOAP协议。SOAP提供了标准的RPC方法来调用Web Service。SOAP协议 = HTTP协议 + XML数据格式SOAP协议定义了SOAP消息的格式，SOAP协议是基于HTTP协议的，SOAP也是基于XML和XSD的，XML是SOAP的数据编码方式。打个比喻：HTTP就是普通公路，XML就是中间的绿色隔离带和两边的防护栏，SOAP就是普通公路经过加隔离带和防护栏改造过的高速公路。 soap基于xml和http，在http的请求头中加入属性用以标记请求内容格式是soap类型的，并且用soap也是和xsd一样，基于xml的基础上自己定义一套标签，来规范webService请求的一系列参数。 WSDL： 好比我们去商店买东西，首先要知道商店里有什么东西可买，然后再来购买，商家的做法就是张贴广告海报。 WebService也一样，WebService客户端要调用一个WebService服务，首先要有知道这个服务的地址在哪，以及这个服务里有什么方法可以调用，所以，WebService务器端首先要通过一个WSDL文件来说明自己家里有啥服务可以对外调用，服务是什么（服务中有哪些方法，方法接受的参数是什么，返回值是什么），服务的网络地址用哪个url地址表示，服务通过什么方式来调用。WSDL(Web Services Description Language)就是这样一个基于XML的语言，用于描述Web Service及其函数、参数和返回值。它是WebService客户端和服务器端都能理解的标准格式。因为是基于XML的，所以WSDL既是机器可阅读的，又是人可阅读的，这将是一个很大的好处。一些最新的开发工具既能根据你的Web service生成WSDL文档，又能导入WSDL文档，生成调用相应WebService的代理类代码。WSDL文件保存在Web服务器上，通过一个url地址就可以访问到它。客户端要调用一个WebService服务之前，要知道该服务的WSDL文件的地址。WebService服务提供商可以通过两种方式来暴露它的WSDL文件地址：1.注册到UDDI服务器，以便被人查找；2.直接告诉给客户端调用者。 WSDL也是在xml的基础上进行扩展，它是用来描述webservice的，描述了WebService有哪些方法、参数类型、访问路径等等。 UDDI： UDDI的目的是为电子商务建立标准；UDDI是一套基于Web的、分布式的、为Web Service提供的、信息注册中心的实现标准规范，同时也包含一组使企业能将自身提供的Web Service注册，以使别的企业能够发现的访问协议的实现标准。也即一种远程服务发布与注册的标准。 Web Service调用方式网络上随处可见的“四种调用webService的方式”都是通过jdk1.6之后集成的组件api进行调用。随处找来的：WebService的四种客户端调用方式（基本）还有其他的开源框架实现了Web Service，比如axis和cxf。 在SOA领域，我们认为Web Service是SOA体系的构建单元（building block）。对于服务开发人员来说，AXIS和CXF一定都不会陌生。这两个产品都是Apache孵化器下面的Web Service开源开发工具。 Axis2的最新版本是1.3.CXF现在已经到了2.0版本。 这两个框架 都是从已有的开源项目发展起来的。Axis2是从Axis1.x系列发展而来。CXF则是XFire和Celtix项目的结合产品。Axis2是从底层全部重新实现，使用了新的扩展性更好模块架构。 CXF也重新的深化了XFire和Celtix这两个开发工具。 新产品的退出导致了几个问题。是不是现有的使用Axis 1.x，XFire和Celix的应用需要迁移的新的版本上。如果一个开发人员确定要迁移它的应用到新的框架上，那么他应该选择哪一个呢？相反的，如果一个开发者决定从头开发一个新的Web Service，他应该使用哪个呢？ 这两个框架哪一个更好一些呢？ 对于系统迁移来说，也许迁移到新的框架并不难。Axis和CXF都提供了迁移的指导。能够给开发者一些迁移的技巧和经验。但是对于这样迁移，这两个开源项目都没有提供迁移的工具。对于这样的迁移工作，尽管很值得去寻找所有的可行方案。Axis2和CXF都有各自不同的WebService开发方法，每个方法都有相当数量拥护者。 通过一个比较矩阵来比较Axis2和CXF变得有现实的意义。这两个项目都开发不够成熟，但是最主要的区别在以下几个方面： 1.CXF支持 WS-Addressing，WS-Policy， WS-RM， WS-Security和WS-I Basic Profile。Axis2不支持WS-Policy，但是承诺在下面的版本支持。 CXF可以很好支持Spring。Axis2不能 AXIS2支持更广泛的数据并对，如XMLBeans，JiBX，JaxMe和JaxBRI和它自定义的数据绑定ADB。注意JaxME和JaxBRI都还是试验性的。CXF只支持JAXB和Aegis。在CXF2.1 Axis2支持多语言-除了Java,他还支持C/C++版本。 比较这两个框架的Web Service开发方法与比较它们的特性同样重要。 从开发者的角度，两个框架的特性相当的不同。 Axis2的开发方式类似一个小型的应用服务器，Axis2的开发包要以WAR的形式部署到Servlet容器中，比如Tomcat，通过这些容器可以对工作中的Web Service进行很好的监控和管理。Axis2 的Web administrion模块可以让我们动态的配置Axis2.一个新的服务可以上载，激活，使之失效，修改web服务的参数。管理UI也可以管理一个或者多个处于运行状态的服务。这种界面化管理方式的一个弊端是所有在运行时修改的参数没有办法保存，因为在重启动之后，你所做的修改就会全部失效。 Axis2允许自己作为独立的应用来发布Web Service，并提供了大量的功能和一个很好的模型，这个模型可以通过它本身的架构（modular architecture）不断添加新的功能。有些开发人员认为这种方式对于他们的需求太过于繁琐。这些开发人员会更喜欢CXF。 CXF更注重开发人员的工效（ergonomics）和嵌入能力（embeddability）。大多数配置都可以API来完成，替代了比较繁琐的XML配置文件， Spring的集成性经常的被提及，CXF支持Spring2.0和CXF’s API和Spring的配置文件可以非常好的对应。CXF强调代码优先的设计方式（code-first design)，使用了简单的API使得从现有的应用开发服务变得方便。 不过你选择Axis2还是CXF，你都可以从开源社区得到大量的帮助。这两个框架都有商业公司提供服务，WSO2提供AXIS2的支持，Iona提供CXF的支持。这两公司都有很活跃的开发者社区。 Axis2出现的时间较早，CXF的追赶速度快。我的建议是：如果你需要多语言的支持，你应该选择AXIS2。如果你需要把你的实现侧重JAVA并希望和Spring集成，CXF就是更好的选择，特别是把你的Web Service嵌入其他的程序中。如果你觉得这两个框架的新特性对于你并没有太大的用处，你会觉得Axis1也是不错的选择，你应该继续使用它知道你有充分的理由去更换它。 cxf方式调用webService参考链接：CXF提供Client调用WebService接口的方法 1、 JaxWsProxyFactoryBean 简介： 调用方式采用了和RMI类似的机制，即客户端直接服务器端提供的服务接口(interface),CXF通过运行时代理生成远程服务的代理对象，在客户端完成对webservice的访问; 几个必填的字段：setAddress-这个就是我们发布webservice时候的地址，保持一致 缺点： 这种调用service的好处在于调用过程非常简单，就几行代码就完成一个webservice的调用，但是客户端也必须依赖服务器端的接口，这种调用方式限制是很大的，要求服务器端的webservice必须是java实现–这样也就失去了使用webservice的意义12345678910import org.apache.cxf.jaxws.JaxWsProxyFactoryBean;public class Client &#123; public static void main(String[] args) &#123; JaxWsProxyFactoryBean bean = new JaxWsProxyFactoryBean(); bean.setServiceClass(HelloWorldService.class); bean.setAddress("http://localhost:9090/helloWorldService"); HelloWorldService helloWorldService = (HelloWorldService)bean.create(); String result = helloWorldService.sayHello("Kevin"); System.out.println(result); &#125; 2、 JaxWsDynamicClientFactory [Dynamic：动态的] 简介： 只要指定服务器端wsdl文件的位置，然后指定要调用的方法和方法的参数即可，不关心服务端的实现方式。 wsdl [Web Services Description Language]网络服务描述语言是Web Service的描述语言，它包含一系列描述某个web service的定义123456789import org.apache.cxf.jaxws.endpoint.dynamic.JaxWsDynamicClientFactory;public class Client2 &#123; public static void main(String[] args) throws Exception &#123; JaxWsDynamicClientFactory clientFactory = JaxWsDynamicClientFactory.newInstance(); Client client = clientFactory.createClient("http://localhost:9090/helloWorldService?wsdl"); Object[] result = client.invoke("sayHello", "KEVIN"); System.out.println(result[0]); &#125; &#125; 3、JaxWsServerFactoryBean 用JaxWsServerFactoryBean发布，需要独立的jetty包。]]></content>
      <categories>
        <category>云服务</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[云服务器、vps、虚拟主机的区别]]></title>
    <url>%2F2019%2F05%2F02%2F%E2%80%9C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%81vps%E3%80%81%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
    <content type="text"><![CDATA[云服务器Elastic Compute Service, 简称ECS 好多人理解云服务器和VPS一样，更有甚者说以前的VPS现在的说法就是云服务器，其实不然，云服务器是一个计算，网络，存储的组合。简单点说就是通过多个CPU，内存，硬盘组成的计算池和存储池和网络的组合。云服务器就是一些实际的硬件设备，通过虚拟化技术，可以大规模统一调度，并当成“一台”机器的技术。你根本看不到它在哪里，看不到它的CPU、内存、硬盘，但是你可以轻松把它当成“一台”现实中的主机来操作，无论是配置软件、测试性能、还是上传文件都和传统服务器没什么区别。优点：价格适中，使用灵活，高可用性（单个或多个物理离线不会对整个服务造成太大的影响）缺点：性能相对较低阮一峰的解释：“云主机”（Cloud hosting）可以看成是新一代的共享主机。首先，主机公司将它的硬件和网络线路，做成一朵”云”，然后提供一些通向这朵”云”的网络接口API，供客户使用。这时，每个客户共享的不再是某一台特定的服务器，而是云里的所有服务器。一个通俗的比喻是，你可以向银行租一个编号为”8888”的保险箱（共享主机），也可以把贵重物品直接交给保管公司（云主机），听任他们保管。更重要的是云服务器可以动态平衡负载，当你的带宽、内存、硬盘不够用的时候，可以随时点击鼠标增加相应服务，通过弹性的调整，来实现满足各种变化的需求，同时还能控制成本，这就是云服务器最大的卖点。自我理解：云服务器并非服务厂商向用户提供一台固定机器的控制权，可能是一个服务器集群的资源，但是最终可供用户使用的性能指标取决于用户购买云服务器时的性能标准（单核、4g等），服务提供商有技术手段可以限制用户最高只能使用到该性能标准的服务。所以当你购买的云服务器满足不了需求时，可以动态地扩容，购买更高的服务资源性能指标。 vpsVirtual Private Server 虚拟专用服务器,一般是将一个独立服务器通过虚拟化技术虚拟成多个虚拟专用服务器。在物理服务器内通过虚拟化技术，在一套操作系统的技术上，虚拟出很多套的独立运行的操作系统出来，从用户角度来看，就像是有很多台服务器可以使用（其实是运行在同一套物理设备里面）。提高了资源的利用率，共享资源从后降低成本。这一套套虚拟出来的独立的操作系统就是VPS。优点：价格便宜缺点：性能低，高可用性低（除了其所在的物理机出问题了会收到影响，虚拟化技术出问题也会收到影响）。 如何区分云服务器和VPS 既然不是一台真正存在的主机，云服务器是不是和VPS虚拟主机很类似呢？其实不然，VPS是一台真实主机虚拟成多个小主机，性能往往得不到保障，而云服务器是数量庞大的服务器阵列，在均衡负载之后诞生很多虚拟主机，无论是数据安全还是性能都有基本的保证。 可以说云服务器是一种类似VPS服务器的虚拟化技术，VPS是采用虚拟软件，VZ或VM在一台服务器上虚拟出多个类似独立服务器的部分，每个部分都可以做单独的操作系统，管理方法同服务器一样。 云服务器是在一组集群服务器上虚拟出多个类似独立服务器的部分，集群中每个服务器上都有云服务器的一个镜像，从而大大提高了虚拟服务器的安全稳定性，除非所有的集群内服务器全部出现问题，云服务器才会无法访问。 虚拟主机虚拟主机其实是在一套安装好的操作系统上将环境配置好（asp+SQLserver、PHP+MySQL等），然后所有的用户公用一套环境。例如现在新增一个用户，那么虚拟主机管理程序直接在设定的路径新建一个文件件、另外在数据库创建一个子数据库，用户将网页代码通过ftp等方式传送到新建的文件夹内，并将数据存入新建的数据库，整个网站就已经弄好了，域名指向绑带后就可以直接使用了。简单快捷，但是因为是和别人公用一套环境，自由度不高，限制较多，很多人公用后性能也一般。 可以理解为在同一个主机之上运行的多个网址，它们共同占用这台主机的资源。如果同主机上有其他的网站访问量比较大，则其他的网站的性能也会受到影响。 拓展链接：https://www.1deng.me/different-types-of-web-hosting.html]]></content>
      <categories>
        <category>云服务</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SOAP和WSDL的一些必要知识]]></title>
    <url>%2F2019%2F05%2F02%2FSOAP%E5%92%8CWSDL%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%85%E8%A6%81%E7%9F%A5%E8%AF%86.html</url>
    <content type="text"><![CDATA[原文地址：https://www.cnblogs.com/JeffreySun/archive/2009/12/14/1623766.htmlSOAP和WSDL对Web Service、WCF进行深入了解的基础，因此花一些时间去了解一下是很有必要的。 一、SOAP(Simple Object Access Protocol) 如果我们要调用远程对象的方法，就必定要告诉对方，我们要调用的是一个什么方法，以及这个方法的参数的值等等。然后对方把数据返回给我们。 这其中就涉及到两个问题：1、数据如何在网络上传输。2、如何表示数据？用什么格式去表示函数以及它的参数等等。 1、SOAP的传输协议 SOAP的传输协议使用的就是HTTP协议。只不过HTTP传输的内容是HTML文本，而SOAP协议传输的是SOAP的数据。看一下下面的例子： 这是一个HTTP请求(请求google的首页)的内容:12345678GET / HTTP/1.1 Accept: image/gif, image/jpeg, image/pjpeg, image/pjpeg, application/x-shockwave-flash, application/x-ms-application, application/x-ms-xbap, application/vnd.ms-xpsdocument, application/xaml+xml, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/msword, */*Accept-Language: en-usUser-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; CIBA) chromeframe/4.0Accept-Encoding: gzip, deflateConnection: Keep-AliveHost: www.google.comCookie: PREF=ID=d8f9f1710bfa5f72:U=a5b3bec86b6433ef:NW=1:TM=1260238598:LM=1260241971:GM=1:S=q2agYsw3BsoOQMAs; NID=29=JgIGDDUx70IQTBVAnNEP_E9PLLKBI9STjzaBjgq1eWuDg-_jCgFpka59DrOC0aZKLbj4q77HU1VMKscXTP3OaseyTbv643c2XPe9dS7lsXDHAkAnS46vy-OU8XRqbmxJ; rememberme=true; SID=DQAAAH4AAABW7M4nVkTeOR7eJUmC1AJ4R6hYbmVewuy_uItLUTzZMUTpojdaHUExhPa_EPAkO9Ex1u3r7aPXZ5cj28xHnv2DbfRYf5AyaBcimciuOTITKSIkqn3QSpGDFkRS1Xn7EGzDpCV0V1xFlCu0erf_jfe_D6GOgC2P2S08jNdFS9Vpmw; HSID=AFEFTMA68EgNjkbil; __utmx=173272373.; __utmxx=173272373.---------如果有Post的数据，这里还会有Post的数据-------- 这个是一个SOAP请求的内容：12345678910POST /WebServices/WeatherWebService.asmx HTTP/1.1User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; MS Web Services Client Protocol 2.0.50727.3603)Content-Type: text/xml; charset=utf-8SOAPAction: &quot;http://WebXml.com.cn/getSupportCity&quot;Host: www.webxml.com.cnContent-Length: 348Expect: 100-continueConnection: Keep-Alive&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;soap:Envelope xmlns:soap=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;&lt;soap:Body&gt;&lt;getSupportCity xmlns=&quot;http://WebXml.com.cn/&quot;&gt;&lt;byProvinceName&gt;广东&lt;/byProvinceName&gt;&lt;/getSupportCity&gt;&lt;/soap:Body&gt;&lt;/soap:Envelope&gt; 可以看到，一个SOAP请求其实就是一个HTTP请求，但为了表明内容是SOAP的数据，需要加入上面请求中红色字的部分来以示区别。也就是说，如果请求头中有SOAPAction这一段，那么请求会被当作SOAP的内容来处理而不会当作HTML来解析。可以用上面指定SOAPAction头来表示内容是SOAP的内容，也可以指定 Content-Type: application/soap+xml 来表示内容是SOAP的内容。SOAP请求中最后的那段XML数据，这个就是请求的具体内容，这个就是SOAP规定的请求的数据格式，下面再详细对格式进行说明。 2、SOAP的数据格式 现在知道了SOAP是通过HTTP协议的POST方法来传输数据的，只不过是请求的Header中加了一些标志来说明自己是一个SOAP请求。那么数据的具体格式是怎么规定的呢，我们把上面请求的XML数据展开看一下：12345678&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt; &lt;soap:Body&gt; &lt;getSupportCity xmlns="http://WebXml.com.cn/"&gt; &lt;byProvinceName&gt;广东&lt;/byProvinceName&gt; &lt;/getSupportCity&gt; &lt;/soap:Body&gt;&lt;/soap:Envelope&gt; 其中的\soap:Body\里面的内容就是请求的内容，请求的方法为getSupportCity，该方法有一个名为byProvinceName的参数，参数的值为“广东”这个字符串。再看一下返回的内容：1&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;&lt;soap:Body&gt;&lt;getSupportCityResponse xmlns="http://WebXml.com.cn/"&gt;&lt;getSupportCityResult&gt;&lt;string&gt;广州 (59287)&lt;/string&gt;&lt;string&gt;深圳 (59493)&lt;/string&gt;&lt;string&gt;潮州 (59312)&lt;/string&gt;&lt;string&gt;韶关 (59082)&lt;/string&gt;&lt;string&gt;湛江 (59658)&lt;/string&gt;&lt;string&gt;惠州 (59298)&lt;/string&gt;&lt;string&gt;清远 (59280)&lt;/string&gt;&lt;string&gt;东莞 (59289)&lt;/string&gt;&lt;string&gt;江门 (59473)&lt;/string&gt;&lt;string&gt;茂名 (59659)&lt;/string&gt;&lt;string&gt;肇庆 (59278)&lt;/string&gt;&lt;string&gt;汕尾 (59501)&lt;/string&gt;&lt;string&gt;河源 (59293)&lt;/string&gt;&lt;string&gt;揭阳 (59315)&lt;/string&gt;&lt;string&gt;梅州 (59117)&lt;/string&gt;&lt;string&gt;中山 (59485)&lt;/string&gt;&lt;string&gt;德庆 (59269)&lt;/string&gt;&lt;string&gt;阳江 (59663)&lt;/string&gt;&lt;string&gt;云浮 (59471)&lt;/string&gt;&lt;string&gt;珠海 (59488)&lt;/string&gt;&lt;string&gt;汕头 (59316)&lt;/string&gt;&lt;string&gt;佛山 (59279)&lt;/string&gt;&lt;/getSupportCityResult&gt;&lt;/getSupportCityResponse&gt;&lt;/soap:Body&gt;&lt;/soap:Envelope&gt; 返回的HTTP头中并没有标志来表明是一个SOAP的响应，因为的确没有必要，请求方发送出的SOAP请求，返回的肯定是SOAP的响应。 一个典型的SOAP请求格式的结构如下：1234567891011121314151617&lt;?xml version="1.0"?&gt;&lt;soap:Envelope xmlns:soap="http://www.w3.org/2001/12/soap-envelope"soap:encodingStyle="http://www.w3.org/2001/12/soap-encoding"&gt;&lt;soap:Header&gt; &lt;m:Trans xmlns:m="http://www.w3schools.com/transaction/" soap:mustUnderstand="1"&gt;234 &lt;/m:Trans&gt;&lt;/soap:Header&gt;&lt;soap:Body&gt; &lt;m:GetPrice xmlns:m="http://www.w3schools.com/prices"&gt; &lt;m:Item&gt;Apples&lt;/m:Item&gt; &lt;/m:GetPrice&gt;&lt;/soap:Body&gt;&lt;/soap:Envelope&gt; 下面逐个解释里面的元素: a) Envelope SOAP的请求内容必须以Envelope做为根节点。 xmlns:soap=”http://www.w3.org/2001/12/soap-envelope&quot;，不能修改，否则会出错。http://www.w3.org/2001/12/soap-envelope里面有Envelope的schema的相关定义。有兴趣的可以去这个链接的内容。 soap:encodingStyle=”http://www.w3.org/2001/12/soap-encoding&quot;，这个指定了数据元素的类型。 b) Header 这个是可选的，如果需要添加Header元素，那么它必须是Envelope的第一个元素。 Header的内容并没有严格的限制，我们可以自己添加一些和应用程序相关的内容，但是客户端一定要记得处理这些Header元素，可以加上mustUnderstand强制进行处理。 c) Body 这个就是请求的主题内容了，请求什么函数，参数是什么类型等等都在这里面指定。 用标签表示一个函数，然后用子元素表示它的参数。 在调用中没有指定参数和返回类型，这里不需要指定，因为提供服务的一方自己已经规定好了数据类型，在调用时指定数据类型没有任何意义。 二、WSDL(Web Services Description Language) WSDL是用来描述WebService的，它用XML的格式描述了WebService有哪些方法、参数类型、访问路径等等。我们要使用一个WebService肯定首先要获取它的WSDL，在VS中添加一个Web 引用时，这些工作由开发环境帮我们做了，开发环境根据WSDL文档给Web Service生成了相应的代理类供我们使用。 下面是一个HelloWorld的WebService的服务端代码： 1234567891011121314public class Service : System.Web.Services.WebService&#123; public Service () &#123; //Uncomment the following line if using designed components //InitializeComponent(); &#125; [WebMethod] public DateTime HelloWorld(int i) &#123; return DateTime.Now; &#125;&#125; 其对应的WebService的WSDL文档如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;wsdl:definitions xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:tm="http://microsoft.com/wsdl/mime/textMatching/" xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:mime="http://schemas.xmlsoap.org/wsdl/mime/" xmlns:tns="http://tempuri.org/" xmlns:s="http://www.w3.org/2001/XMLSchema" xmlns:soap12="http://schemas.xmlsoap.org/wsdl/soap12/" xmlns:http="http://schemas.xmlsoap.org/wsdl/http/" targetNamespace="http://tempuri.org/" xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"&gt; &lt;wsdl:types&gt; &lt;s:schema elementFormDefault="qualified" targetNamespace="http://tempuri.org/"&gt; &lt;s:element name="HelloWorld"&gt; &lt;s:complexType&gt; &lt;s:sequence&gt; &lt;s:element minOccurs="1" maxOccurs="1" name="i" type="s:int" /&gt; &lt;/s:sequence&gt; &lt;/s:complexType&gt; &lt;/s:element&gt; &lt;s:element name="HelloWorldResponse"&gt; &lt;s:complexType&gt; &lt;s:sequence&gt; &lt;s:element minOccurs="1" maxOccurs="1" name="HelloWorldResult" type="s:dateTime" /&gt; &lt;/s:sequence&gt; &lt;/s:complexType&gt; &lt;/s:element&gt; &lt;/s:schema&gt; &lt;/wsdl:types&gt; &lt;wsdl:message name="HelloWorldSoapIn"&gt; &lt;wsdl:part name="parameters" element="tns:HelloWorld" /&gt; &lt;/wsdl:message&gt; &lt;wsdl:message name="HelloWorldSoapOut"&gt; &lt;wsdl:part name="parameters" element="tns:HelloWorldResponse" /&gt; &lt;/wsdl:message&gt; &lt;wsdl:portType name="ServiceSoap"&gt; &lt;wsdl:operation name="HelloWorld"&gt; &lt;wsdl:input message="tns:HelloWorldSoapIn" /&gt; &lt;wsdl:output message="tns:HelloWorldSoapOut" /&gt; &lt;/wsdl:operation&gt; &lt;/wsdl:portType&gt; &lt;wsdl:binding name="ServiceSoap" type="tns:ServiceSoap"&gt; &lt;soap:binding transport="http://schemas.xmlsoap.org/soap/http" /&gt; &lt;wsdl:operation name="HelloWorld"&gt; &lt;soap:operation soapAction="http://tempuri.org/HelloWorld" style="document" /&gt; &lt;wsdl:input&gt; &lt;soap:body use="literal" /&gt; &lt;/wsdl:input&gt; &lt;wsdl:output&gt; &lt;soap:body use="literal" /&gt; &lt;/wsdl:output&gt; &lt;/wsdl:operation&gt; &lt;/wsdl:binding&gt; &lt;wsdl:binding name="ServiceSoap12" type="tns:ServiceSoap"&gt; &lt;soap12:binding transport="http://schemas.xmlsoap.org/soap/http" /&gt; &lt;wsdl:operation name="HelloWorld"&gt; &lt;soap12:operation soapAction="http://tempuri.org/HelloWorld" style="document" /&gt; &lt;wsdl:input&gt; &lt;soap12:body use="literal" /&gt; &lt;/wsdl:input&gt; &lt;wsdl:output&gt; &lt;soap12:body use="literal" /&gt; &lt;/wsdl:output&gt; &lt;/wsdl:operation&gt; &lt;/wsdl:binding&gt; &lt;wsdl:service name="Service"&gt; &lt;wsdl:port name="ServiceSoap" binding="tns:ServiceSoap"&gt; &lt;soap:address location="http://localhost:2206/WebSite1/Service.asmx" /&gt; &lt;/wsdl:port&gt; &lt;wsdl:port name="ServiceSoap12" binding="tns:ServiceSoap12"&gt; &lt;soap12:address location="http://localhost:2206/WebSite1/Service.asmx" /&gt; &lt;/wsdl:port&gt; &lt;/wsdl:service&gt;&lt;/wsdl:definitions&gt; 一个WSDL文档由四部分组成： 1、types 指定了WebService用到的所有数据类型，上面用到了两种数据类型，int和datetime 2、message 指明一个操作所用到的数据类型。 HelloWorldSoapIn是指HelloWorld的输入操作用到的数据类型，HelloWorldSoapOut是指HelloWorld的输出操作用到的数据类型。二者的element元素指出了与types中对应到的具体类型。 3、portType 指出了这个WebService所有支持的操作，就是说有哪些方法可供调用。 这里支持一个HelloWorld调用，它的输入和输出对应到HelloWorldSoapIn和HelloWorldSoapOut这个两个数据类型。 4、binding soap12:binding元素的transport指明传输协议，这里是http协议。 operation 指明要暴露给外界调用的操作。 use属性指定输入输出的编码方式，这里没有指定编码。 5、services 指定服务的一些信息，主要是指定服务的访问路径。]]></content>
      <categories>
        <category>云服务</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[dubbo和zookeeper的关系]]></title>
    <url>%2F2019%2F05%2F02%2Fdubbo%E5%92%8Czookeeper%E7%9A%84%E5%85%B3%E7%B3%BB.html</url>
    <content type="text"><![CDATA[转载前言：网络上很多教程没有描述zookeeper和dubbo到底是什么关系、分别扮演了什么角色等信息，都是说一些似是而非的话，这里终于找到一篇文章，比较生动地描述了注册中心和微服务框架之间的关系，以及他们之间的合作分工。 下面附上我读完之后的理解： dubbo是一个远程调用服务的分布式框架，可以实现远程通讯、动态配置、地址路由等等功能。比如在入门demo里的暴露服务，使得远程调用的协议可以使用dobbo协议(dubbo://x.x.x.x)或者其它协议，可以配置zookeeper集群地址，实现软负载均衡并配置均衡方式等。在不搭配注册中心的时候，它也是可以实现服务端和调用端的通信的，这种方式是点对点通信的，所谓“没有中间商”。但是如果配置服务发布和调用端过多特别是集群的方式提供服务的时候，就会暴露许多的问题：增加节点需要修改配置文件、服务端机器宕机后不能被感知等。 它可以通过集成注册中心，来动态地治理服务发布和服务调用。相当于把服务注册和发布推送的功能分摊给了(zookeeper)注册中心。 原帖地址：https://www.javazhiyin.com/28425.html#m 介绍微服务是最近比较火的概念，而微服务框架目前主流的有Dubbo和Spring Cloud，两者都是为了解决微服务遇到的各种问题而产生的，即遇到的问题是一样的，但是解决的策略却有所不同，所以这2个框架经常拿来比较。没用过Dubbo的小伙伴也不用担心，其实Dubbo还是比较简单的，看完本文你也能掌握一个大概，重要的不是代码，而是思想。 Dubbo实现服务调用是通过RPC的方式，即客户端和服务端共用一个接口(将接口打成一个jar包，在客户端和服务端引入这个jar包)，客户端面向接口写调用，服务端面向接口写实现，中间的网络通信交给框架去实现，想深入了解的看推荐阅读。原文链接有代码GitHub地址 使用入门服务提供者定义服务接口 123public interface DemoService &#123; String sayHello(String name);&#125; 在服务提供方实现接口 123456public class DemoServiceImpl implements DemoService &#123; @Override public String sayHello(String name) &#123; return "Hello " + name; &#125;&#125; 用 Spring 配置声明暴露服务 provider.xml（省略了beans标签的各种属性） 1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans&gt; &lt;!-- 当前项目在整个分布式架构里面的唯一名称，用于计算依赖关系 --&gt; &lt;dubbo:application name="helloworld-app" /&gt; &lt;!--dubbo这个服务所要暴露的服务地址所对应的注册中心，N/A为不使用注册中心--&gt; &lt;dubbo:registry address="N/A"/&gt; &lt;!--当前服务发布所依赖的协议；webserovice、Thrift、Hessain、http--&gt; &lt;dubbo:protocol name="dubbo" port="20880"/&gt; &lt;!--服务发布的配置，需要暴露的服务接口--&gt; &lt;dubbo:service interface="com.st.DemoService" ref="demoService"/&gt; &lt;!--bean的定义--&gt; &lt;bean id="demoService" class="com.st.DemoServiceImpl"/&gt;&lt;/beans&gt; 加载 Spring 配置 12345678public class Provider &#123; public static void main(String[] args) throws Exception &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("provider.xml"); context.start(); System.in.read(); // 按任意键退出 &#125;&#125; 服务消费者consumer.xml 12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans&gt; &lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt; &lt;dubbo:application name="consumer-of-helloworld-app"/&gt; &lt;dubbo:registry address="N/A"/&gt; &lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&gt; &lt;dubbo:reference id="demoService" interface="com.st.DemoService" url="dubbo://localhost:20880/com.st.DemoService"/&gt;&lt;/beans&gt; 加载Spring配置，并调用远程服务 12345678910111213public class Consumer &#123; public static void main(String[] args) throws Exception &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("consumer.xml"); context.start(); // 获取远程服务代理 DemoService demoService = (DemoService)context.getBean("demoService"); // 执行远程方法 String hello = demoService.sayHello("world"); // Hello world System.out.println( hello ); &#125;&#125; 这就是典型的点对点的服务调用。当然我们为了高可用，可以在consumer.xml中配置多个服务提供者，并配置响应的负载均衡策略 配置多个服务调用者在comsumer.xml的dubbo:reference标签的url属性中加入多个地址，中间用分号隔开即可配置负载均衡策略在comsumer.xml的dubbo:reference标签中增加loadbalance属性即可，值可以为如下四种类型 RoundRobin LoadBalance，随机，按权重设置随机概率。 RoundRobin LoadBalance，轮询，按公约后的权重设置轮询比率。 LeastActive LoadBalance，最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。 ConsistentHash LoadBalance，一致性 Hash，相同参数的请求总是发到同一提供者。 12345&lt;dubbo:reference id="demoService" interface="com.st.DemoService" url="dubbo://192.168.11.1:20880/com.st.DemoService; dubbo://192.168.11.2:20880/com.st.DemoService; dubbo://192.168.11.3:20880/com.st.DemoService" loadbalance="roundrobin"/&gt; 现在整体架构是如下图（假设服务消费者为订单服务，服务提供者为用户服务）： 这样会有什么问题呢？ 当服务提供者增加节点时，需要修改配置文件 当其中一个服务提供者宕机时，服务消费者不能及时感知到，还会往宕机的服务发送请求 这个时候就得引入注册中心了 注册中心 Dubbo目前支持4种注册中心,（multicast zookeeper redis simple） 推荐使用Zookeeper注册中心，本文就讲一下用zookeeper实现服务注册和发现（敲黑板，又一种zookeeper的用处），大致流程如下 现在我们来看Dubbo官网对Dubbo的介绍图，有没有和我们上面画的很相似 节点角色说明 节点 角色说明 Provider 暴露服务的服务提供方 Consumer 调用远程服务的服务消费方 Registry 服务注册与发现的注册中心 Monitor 统计服务的调用次数和调用时间的监控中心 Container 服务运行容器 调用关系说明 服务容器负责启动（上面例子为Spring容器），加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 要使用注册中心，只需要将provider.xml和consumer.xml更改为如下 12&lt;!--&lt;dubbo:registry address="N/A"/&gt;--&gt;&lt;dubbo:registry protocol="zookeeper" address="192.168.11.129:2181"/&gt; 如果zookeeper是一个集群，则多个地址之间用逗号分隔即可 1&lt;dubbo:registry protocol="zookeeper" address="192.168.11.129:2181,192.168.11.137:2181,192.168.11.138:2181"/&gt; 把consumer.xml中配置的直连的方式去掉 123456&lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&gt;&lt;!--&lt;dubbo:reference id="demoService" interface="com.st.DemoService"--&gt; &lt;!--url="dubbo://localhost:20880/com.st.DemoService"/&gt;--&gt;&lt;dubbo:reference id="demoService" interface="com.st.DemoService"/&gt; 注册信息在zookeeper中如何保存？ 启动上面服务后，我们观察zookeeper的根节点多了一个dubbo节点及其他，图示如下 最后一个节点中192.168.1.104是小编的内网地址，你可以任务和上面配置的localhost一个效果，大家可以想一下我为什么把最后一个节点标成绿色的。没错，最后一个节点是临时节点，而其他节点是持久节点，这样，当服务宕机时，这个节点就会自动消失，不再提供服务，服务消费者也不会再请求。如果部署多个DemoService，则providers下面会有好几个节点，一个节点保存一个DemoService的服务地址 其实一个zookeeper集群能被多个应用公用，如小编Storm集群和Dubbo配置的就是一个zookeeper集群，为什么呢？因为不同的框架会在zookeeper上建不同的节点，互不影响。如dubbo会创建一个/dubbo节点，storm会创建一个/storm节点，如图 zookeeper相关介绍Zookeeper 是 Apacahe Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为 Dubbo 服务的注册中心，工业强度较高，可用于生产环境，并推荐使用。 流程说明： 服务提供者启动时: 向 /dubbo/com.foo.BarService/providers 目录下写入自己的 URL 地址 服务消费者启动时: 订阅 /dubbo/com.foo.BarService/providers 目录下的提供者 URL 地址。并向 /dubbo/com.foo.BarService/consumers 目录下写入自己的 URL 地址 监控中心启动时: 订阅 /dubbo/com.foo.BarService 目录下的所有提供者和消费者 URL 地址。 支持以下功能： 当提供者出现断电等异常停机时，注册中心能自动删除提供者信息 当注册中心重启时，能自动恢复注册数据，以及订阅请求 当会话过期时，能自动恢复注册数据，以及订阅请求 当设置 &lt;dubbo:registry check=&quot;false&quot; /&gt; 时，记录失败注册和订阅请求，后台定时重试 可通过 &lt;dubbo:registry username=&quot;admin&quot; password=&quot;1234&quot; /&gt; 设置 zookeeper 登录信息 可通过 &lt;dubbo:registry group=&quot;dubbo&quot; /&gt; 设置 zookeeper 的根节点，不设置将使用无根树 支持 * 号通配符 &lt;dubbo:reference group=&quot;*&quot; version=&quot;*&quot; /&gt;，可订阅服务的所有分组和所有版本的提供者 Dubbo相关介绍 Dubbo是什么？ Dubbo是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。简单的说，dubbo就是个服务框架，如果没有分布式的需求，其实是不需要用的，只有在分布式的时候，才有dubbo这样的分布式服务框架的需求，并且本质上是个服务调用的东东，说白了就是个远程服务调用的分布式框架（告别Web Service模式中的WSdl，以服务者与消费者的方式在dubbo上注册）其核心部分包含: 远程通讯: 提供对多种基于长连接的NIO框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。 集群容错: 提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。 自动发现: 基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。 Dubbo能做什么？ 透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。 软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点。 服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。 Dubbo采用全Spring配置方式，透明化接入应用，对应用没有任何API侵入，只需用Spring加载Dubbo的配置即可，Dubbo基于Spring的Schema扩展进行加载。]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[dubbo学习笔记：快速搭建]]></title>
    <url>%2F2019%2F05%2F02%2Fdubbo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA.html</url>
    <content type="text"><![CDATA[搭建一个简单的dubbo服务参考地址： dubbo官网:http://dubbo.apache.org/zh-cn/docs/user/references/registry/zookeeper.html博客:http://www.cnblogs.com/lighten/p/6828026.html 以上两个教程经实践发现都有部分谬误，本教程做了一定更正 1.简介dubbo是一个分布式服务框架，由阿里巴巴的工程师开发，致力于提供高性能和透明化的RPC远程服务调用。可惜的是该项目在2012年之后就没有再更新了，之后由当当基于dubbo开发了dubbox。这里对dubbo的入门构建进行简单的介绍。不涉及dubbo的运行机制，只是搭建过程，方便学习者快速构建项目，运行、熟悉该框架。 dubbo提供了两种构建项目的方法： 通过Spring容器快速构建，其中还有注解的方式； 通过直接使用API（不推荐）。以下对其一一说明。 2.spring配置的形式1.导入maven依赖12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!--如果引入的是2.6.2以下版本，xml文件头引入的xsd地址会报错--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.6.3&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;!-- 排除传递spring依赖 --&gt; &lt;artifactId&gt;spring&lt;/artifactId&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--下面分别是两种不同的zookeeper客户端实现，选择一种就好--&gt;&lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.4&lt;/version&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--后期可能还会用到如下zookeeper客户端jar包依赖，但是目前这个demo不引入也没有问题--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.3.3&lt;/version&gt; &lt;/dependency&gt;&lt;!--spring配置方式，自然需要spring相关的依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;3.2.17.RELEASE&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--打印日志相关--&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.6.4&lt;/version&gt;&lt;/dependency&gt; zkclient和curator curator和zkclient分别为两种不同的zookeeper实现，两者使用的同时都需要开启先zookeeper注册中心的服务端。(关于如何下载配置并启动zookeeper服务端，参考win10环境下搭建zookeeper伪集群)在本项目中，它默认是使用了curator实现的，要改成zkclient实现，需要在&lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181/&quot; client=&quot;zkclient&quot; /&gt;标签中加入 client=&quot;zkclient&quot;，并换成zkclient的依赖。(在dubbo官网中称2.5以上的dubbo版本默认使用zookeeper实现，但是实测结果却相反) 2.定义服务接口(对提供方和调用方都可见)12345package dubboXml;public interface DemoService &#123; String sayHello(String name);&#125; 3.服务提供方配置 实现服务接口 1234567package dubboXml;public class DemoServiceImpl implements DemoService&#123; public String sayHello(String name) &#123; return "Hello " + name; &#125;&#125; spring配置 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://dubbo.apache.org/schema/dubbo" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"&gt; &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt; &lt;dubbo:application name="hello-world-app" /&gt; &lt;!-- 使用zookeeper注册中心暴露服务地址 --&gt; &lt;dubbo:registry address="zookeeper://127.0.0.1:2181" client="zkclient" /&gt; &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt; &lt;dubbo:protocol name="dubbo" port="20880" /&gt; &lt;!-- 声明需要暴露的服务接口 --&gt; &lt;dubbo:service interface="dubboXml.DemoService" ref="demoService" /&gt; &lt;!-- 和本地bean一样实现服务 --&gt; &lt;bean id="demoService" class="dubboXml.DemoServiceImpl" /&gt;&lt;/beans&gt; 读取配置，提供服务 1234567891011package dubboXml;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Provider &#123; public static void main(String[] args) throws Exception &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[] &#123;"provider.xml"&#125;); context.start(); System.in.read(); // 按任意键退出 &#125;&#125; 4.服务调用方配置 spring配置 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://dubbo.apache.org/schema/dubbo" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"&gt; &lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt; &lt;dubbo:application name="consumer-of-helloworld-app" /&gt; &lt;!-- 使用zookeeper注册中心暴露发现服务地址 --&gt; &lt;dubbo:registry address="zookeeper://127.0.0.1:2181" /&gt; &lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&gt; &lt;dubbo:reference id="demoService" interface="dubboXml.DemoService" /&gt;&lt;/beans&gt; 读取配置，调用服务 12345678910111213package dubboXml;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Consumer &#123; public static void main(String[] args) throws Exception &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[] &#123;"consumer.xml"&#125;); context.start(); DemoService demoService = (DemoService)context.getBean("demoService"); // 获取远程服务代理 String hello = demoService.sayHello("nihao"); // 执行远程方法 System.out.println( hello ); // 显示调用结果 &#125;&#125; 最终结果: 5.其他说明 如果涉及传输对象，那么被传输的对象类应该实现serializable接口。因为对象远程传输是以二进制的形式进行的，那么在传输之前需要实现序列化。 我的demo地址:demoXml 我的目录结构: 3.注解配置的方式maven配置同上。 1.服务接口和传输对象服务接口 12345678910package com.common.server;import java.util.List;public interface DemoService &#123; public String greet(String name); public List&lt;User&gt; getUsers();&#125; 传输对象：实现序列化接口 123456789101112131415161718192021222324252627282930313233343536373839404142package com.common.server;import java.io.Serializable;public class User implements Serializable &#123; private static final long serialVersionUID = 1L; private String name; private int age; private String sex; public User(String name, int age, String sex) &#123; this.name = name; this.age = age; this.sex = sex; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; @Override public String toString() &#123; return "User [name=" + name + ", age=" + age + ", sex=" + sex + "]"; &#125;&#125; 2.服务提供方 实现接口(注意加上相应注解) 123456789101112131415161718192021222324252627282930313233343536package com.provider;import com.alibaba.dubbo.config.annotation.Service;import com.common.server.DemoService;import com.common.server.User;import java.util.ArrayList;import java.util.List;/** * 实现类上打上service注解：注意，是dubbo的service注解 */@Servicepublic class DemoServiceImpl implements DemoService &#123; @Override public String greet(String name) &#123; return "Hello " + name; &#125; @Override public List&lt;User&gt; getUsers() &#123; List&lt;User&gt; list = new ArrayList&lt;&gt;(); User user1 = new User("张三",10,"男"); User user2 = new User("李四",11,"女"); User user3 = new User("王五",12,"男"); list.add(user1); list.add(user2); list.add(user3); return list; &#125;&#125; xml配置(与全xml配置服务的方式相比，这里去掉了bean和&lt;dubbo:service&gt;，使用&lt;dubbo:anotition&gt;取代了，相当于自动扫描并暴露服务) 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"&gt; &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt; &lt;dubbo:application name="provider" /&gt; &lt;!-- 使用zookeeper注册中心暴露服务地址 --&gt; &lt;dubbo:registry address="zookeeper://127.0.0.1:2181" client="zkclient" /&gt; &lt;!--&lt;dubbo:registry address="N/A"/&gt;--&gt; &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt; &lt;dubbo:protocol name="dubbo" port="20880" /&gt; &lt;!-- 注解实现，指向服务提供者实现类的包扫描--&gt; &lt;dubbo:annotation package="com.provider" /&gt;&lt;/beans&gt; 开启服务提供 1234567891011121314151617package com.provider;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.io.IOException;/** * 服务提供者 */public class Provider &#123; public static void main(String[] args) throws IOException &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]&#123;"provider.xml"&#125;); context.start(); System.in.read(); &#125;&#125; 3.服务调用方 类中注入并使用远程服务代理（为什么不在加载spring文件的类中注入？因为那是入口) 12345678910111213141516171819202122package com.consumer;import com.alibaba.dubbo.config.annotation.Reference;import com.common.server.DemoService;import org.springframework.stereotype.Component;/** * 服务消费者：service是spring的注解 */@Component("anotationConsumer")public class AnotationConsumer &#123; /** * 远程服务代理，可以和本地bean一样使用demoService */ @Reference(check = false) private DemoService demoService; public void print()&#123; System.out.println(demoService.greet("张三")); System.out.println(demoService.getUsers()); &#125;&#125; consumer.xml spring配置文件 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"&gt; &lt;dubbo:application name="consumer"/&gt; &lt;dubbo:registry address="zookeeper://127.0.0.1:2181" client="zkclient" /&gt; &lt;!--指向服务调用者所在的包--&gt; &lt;dubbo:annotation package="com.consumer" /&gt; &lt;!-- 配置spring注解包扫描 --&gt; &lt;context:component-scan base-package="com.consumer"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 启动服务 1234567891011121314package com.consumer;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Consumer &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]&#123;"consumer.xml"&#125;); context.start(); AnotationConsumer anotationConsumer = (AnotationConsumer) context.getBean("anotationConsumer"); anotationConsumer.print(); &#125;&#125; 调用结果: 4.附加信息 无论是哪种配置方式，如果使用了注册中心，那么注册和调用的时候必须先开启注册中心。 demo地址：dubboAnotation 还有一种api调用的形式，由于不常用所以这里没有提供教程。如果有兴趣可以查看参考帖。]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机网络原理（一）：计算机网络概述]]></title>
    <url>%2F2019%2F05%2F01%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0.html</url>
    <content type="text"><![CDATA[计算机网络概述计算机网络基本概念计算机网络计算机网络是互连的、自治的计算机集合。 协议计算机网络中的实体在进行数据交换的过程中必须遵循的规定或约定，称为网络协议。 协议的三个要素： 语法（定义实体间交换信息的格式和结构，或者定义实体（比如硬件设备）之间传输信号的电平等。 语义（实体间交换的控制信息等） 时序（也称同步，定义实体之间交换信息的顺序以及如何匹配和适应彼此的速度） 计算机网络的功能 硬件功能共享 软件功能共享 信息资源共享 计算机网络的分类 按照覆盖范围 个域网、局域网、城域网、广域网 按拓扑机构分 星形拓扑结构、总线型拓扑结构、环形拓扑结构、网状拓扑结构、树形、混合型 按交换方式分 电报网络交换、报文交换、分组交换 按网络用户属性分 公用网、私有网 计算机网络结构网络边缘各终端 接入网络终端设备和网络核心（网络服务提供商）的连接部分。分为： 电话拨号接入 非对称数字用户线路ADSL 混合光纤同轴电缆HFC接入网络 局域网 移动接入网络 网络核心由通信链路互连的分组交换设备构成的网络，作用是实现网络边缘中主机之间的数据中继和转发。 数据交换技术数据交换的概念通信终端之间通过交换设备进行数据的中继和转发进行数据通信。 1. 电路交换建立电路–&gt;传输数据–&gt;拆除电路 2. 报文交换通过交换节点将整条报文进行中继转发。 3. 分组交换目前广泛采用的互联网通信技术。将报文分割成数据块，每个数据库附上一定的控制信息构成数据分组。每个分组独立传输到目的地，到达后重新组装，还原成报文。 优点 交换设备存储容量要求低 交换速度快 可靠传输率高 更加公平 分组长度的确定略 计算机网络性能1. 速率与带宽基本单位bit/s 2. 时延（延迟） 节点处理时延（传进节点时处理过程） 排队时延 传输时延（传出节点过程） 传播时延 3. 时延带宽积物理链路的传播时延和链路带宽的乘积 4. 丢包率网络拥塞严重时，新到达的分组无法甚至已无缓存空间暂存改分组，此时交换结点会丢弃分组，此所谓“丢包”。 5. 吞吐量理想状况下越等于链路瓶颈的带宽（短板）。 计算机网络体系结构计算机网络分层体系结构将网络功能及其通信协议分层。 OSI参考模型7层。 分别是： 物理层（底层） 在传输介质上实现无结构比特流传输。 规定数据终端设备与数据通信设备之间接口的相关特性，主要包括机械、电气、功能、规程4个方面的特性。 数据链路层 实现在相邻结点之间数据可靠而有效的传输（单位：帧）。 寻址 网络层 解决将分组通过交换网络传送至目的主机，负责转发和路由（单位：数据分组）。 流量控制。 寻址 传输层 第一个端到端的层次，也是进程到进程的层次。 复用/分解、端到端的可靠数据传输传输、连接控制、流量控制和拥塞控制机制。 会话层 对进程之间会话进行管理与控制。 一般被应用层覆盖，很少独立存在。 表示层 处理应用实体之间交换数据的语法，其目的是解决格式和数据表示的差别，从而实现数据能被交换双方所理解。 某些网络中由应用层实现，而且表示层不独立存在。 应用层（顶层） 直接提供给用户以网络服务，包括文件传送、电子邮件、p2p应用等。 为用户提供了一个使用网络应用的接口。 OSI参考模型的7层中，1~3层主要是完成数据交换和数据传输，称之为网络低层；5~7层主要是完成信息处理服务的功能，称之为网络高层；低层与高层之间由第4层衔接。 有关术语数据单元：层之间传送的比特组。服务访问点：相邻层之间，高层可以访问低层的接口。服务原语： 请求：用户实体请求服务做某种工作。 指示：用户实体被告知某件事发生。 响应：用户实体对某件事的响应。 证实：用户实体收到关于它请求的答复。 面向连接的服务： 欲传送数据，先给出对方全称地址，并请求建立连接，对方同意后就建立了通信链路。 传送数据，通常以分组为单位，按序传送，不再标称地址而标称链路号，接收方对成功接收的数据予以确认，称为可靠传输方式。 数据传送结束后，拆除链路。无连接服务：没有建立和拆除链路的过程，每个分组信息带有全称路径，独立选择路径，通常到达的时序也是不确定的，接收之后要重新排序组合。 TCP/IP参考模型4层。 应用层 合并了会话层和表示层 传输层 为进程之间提供逻辑通信 网络互联层 整个参考模型的核心，负责将数据分组发送到目的地。 网络接口层 对应OSI参考模型中的数据链路层和物理层。 五层参考模型基于上两种模型，将表示层和会话层合并到应用层。这是近年来，在描述计算机网络中最常用、最接近实际网络的参考模型。5层分别是： 物理层 数据链路层 网络层 传输层 应用层 基于5层参考模型来描述网络通信的过程，如上图。用户的数据在应用层以报文的形式开始向下一层封装，形成段、数据报、帧，最后以比特流的形式进行传输。在中间节点处，例如路由器、交换机，分别从对应的数据报、帧中取出相应的路由或地址信息并进行处理，并依据转发策略向正确的接口转发数据报或帧。当数据到达目的主机后，自下而上，逐层处理并去掉相应的头部信息，最终还原为最初的报文，交付给用户。]]></content>
      <categories>
        <category>自考</category>
        <category>计算机网络原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机网络原理（二）：网络应用]]></title>
    <url>%2F2019%2F05%2F01%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8.html</url>
    <content type="text"><![CDATA[网络应用计算机网络应用体系结构客户/服务器(c/s)结构网络应用最典型、最基本的网络应用。客户端发送请求，服务器响应请求。 纯P2P结构网络应用端对端的应用，每个对等端同时扮演客户端和服务器的角色。 混合结构网络应用以上两种结构的混合态。 网络应用通信基本原理网络应用的本质是运行在不同的主机上（当然也可运行在同一主机上）的应用之间的通信。进程之间通信并非是高层与高层之间直接通信，而是层层封装，最终形成比特流在物理链路上进行传输。到达目的端的相应层之后，再拆分开来，取出每一层对应的头部信息。两个应用进程看起来就像在直接通信一样，其实并非如此，而是逻辑上可以这样抽象地看待，所以也称为逻辑通信。 域名系统为服务器主机ip地址起的一个更容易读懂和记忆的别名。域名解析就是将这个别名映射为真实的ip地址的过程，实现域名解析需要域名服务器。 层次化域名空间树形结构 域名服务商一个服务器所负责管辖的（或有权限的）范围叫做区。每个区设置相应的权威域名服务器，用来保存该区中所有的主机域名到ip地址的映射。每台主机在进行网络配置时，都会配置一个域名服务器作为默认域名服务器，这个域名服务器被称为本地域名服务器。 根据域名解析过程中的作用和保存的域名信息，可以将域名服务器分为4类： 根域名服务器：最重要的域名服务器。全球13个，知道所有的顶级域名服务器的域名和ip地址，当本地域名服务器无法解析地址，首先请求根域名服务器。顶级域名服务器：对应域名最后一个名字，对一个行业的命名，如com、org等，或对一个区域的命名，如cn、us等。权威域名服务器：负责一个区的域名服务器，任何一个拥有域名的的主机，其域名和ip信息都保存在所在网络的权威域名服务器上。中间域名服务器：不属于前三者。比如www.abc.xyz.com，则com是顶级域名服务器，中间域名服务器xyz.com，权威域名服务器abc.xyz.com。 域名解析过程递归解析和迭代解析：提供递归解析的域名服务器，会进行层层递归查询，将最终的结果返回给查询主机或服务器。提供迭代解析的域名服务器，则会将下一步需要查询的域名服务器信息返回给查询主机和服务器。 通常本地域名服务器都提供递归查询服务。根域名服务器通常只提供迭代查询服务。 为了缓解根域名服务器的压力，通常通过机制来达到： 各域名服务器将每次的结果缓存起来，下次查询到相同的域名时候直接从本机取。 本地域名服务器中存储顶级域名服务器的信息。 万维网应用world wide web.使用超文本传输协议（http）进行数据交互。 Http概述web应用的应用层协议，定义web服务器与客户端如何进行交互。 Http连接http基于传输层的Tcp传输报文。在发送请求之前需要建立tcp连接。 非持久连接 并行连接 持久连接 HTTP报文由起始行、首部行、空白行、实体主题组成。可分为请求报文和响应报文两类。 cookie解决Http无状态的问题。cookie技术包括下面4部分内容： 响应头的set-cookie字段。 客户端本地存储cookie文件。 再次请求时会发送存储的cookie头行。 服务器根据cookie的id维护用户数据。 Internet电子邮件电子邮件系统结构 邮件的发送与接收过程: 用户A首先利用用户代理撰写邮件，包括填写收件人邮箱地址等，然后基于SMTP将邮件发送到其注册的邮件服务器A的外出邮件队列中，等待邮件服务器发送； 邮件服务器A从队列中取出用户A的邮件，基于SMTP发送给邮件服务器B； 邮件服务器B将邮件存放到用户B的邮箱中； 在某个时刻，用户B利用用户代理连接邮件服务器B上运行的邮件读取服务，基于邮件读取协议(POP、IMAP)，将其邮箱中的邮件传输到本地，或者对邮箱中的邮件进行阅读、移动等操作。 用户代理指的是客户端软件 SMTP电子邮件中核心应用层协议，实现邮件服务器之间或客户端到邮件服务器之间的邮件传输。熟知端口号25。 电子邮件格式与MIMEMIME是SMTP的扩展，实现了将非7位ASCII码转换成7位ASCII码文本内容的标准，然后再利用SMTP进行传输。 邮件读取协议POP3、IMAP、HTTP，其中HTTP被用作web mail系统的邮件读取协议。 POP3：最简单的邮件读取协议。熟知端口110。明文传输。下载到客户端本地查看。 IMAP:对服务器远程操作。 HTTP：客户端和邮件服务器之间的交互无论是发送还是接收邮件都是http协议。 FTP文件传送协议。使用两个并行的tcp连接，一个是控制连接（熟知端口21），一个是数据连接（熟知端口21）。 p2p应用优势：每个对等端既是客户端（上传者）又是服务端（下载端），随着对等端的增加几乎不会影响网络性能，而相对的c/s结构的性能瓶颈在于服务器的带宽。 socket编程socket套接字：应用层调用传输层的接口。]]></content>
      <categories>
        <category>自考</category>
        <category>计算机网络原理</category>
      </categories>
  </entry>
</search>
